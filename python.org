#+TITLE: Python
#+AUTHOR: LavenLiu
#+DATE: 2010-05-04
#+EMAIL: ldczz2008@163.com 

#+LaTeX_CLASS: book
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[top=2.1cm,bottom=2.1cm,left=2.1cm,right=2.1cm]{geometry}
#+LaTeX_HEADER: \setmainfont[Mapping=tex-text]{Times New Roman}
#+LaTeX_HEADER: \setsansfont[Mapping=tex-text]{Tahoma}
#+LaTeX_HEADER: \setmonofont{Courier New}
#+LaTeX_HEADER: \setCJKmainfont[BoldFont={Adobe Heiti Std},ItalicFont={Adobe Kaiti Std}]{Adobe Song Std}
#+LaTeX_HEADER: \setCJKsansfont{Adobe Heiti Std}
#+LaTeX_HEADER: \setCJKmonofont{Adobe Fangsong Std}
#+LaTeX_HEADER: \punctstyle{hangmobanjiao}
#+LaTeX_HEADER: \usepackage{color,graphicx}
#+LaTeX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{colortbl}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage[bf,small,indentafter,pagestyles]{titlesec}

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style2.css" />

#+OPTIONS: ^:nil
#+OPTIONS: tex:t

* 数据结构和算法
** 链表
 #+BEGIN_SRC python
class Node:
  def __init__(self, data):
	  self.data = data
	  self.next = None


class LinkedList:
  def __init__(self):
	  self.head = None
	  self.tail = None

  def append(self, data):
	  node = Node(data)
	  if self.head is None:
		  self.head = node
		  self.tail = node
	  else:
		  self.tail.next = node
		  self.tail = node

  def iter(self):
	  if not self.head:
		  return
	  cur = self.head
	  yield cur.data
	  while cur.next:
		  cur = cur.next
		  yield cur.data

  def insert(self, idx, value):
	  cur = self.head
	  cur_idx = 0
	  while cur_idx < idx-1:
		  cur = cur.next
		  if cur is None:
			  raise Exception('list length less than index')
		  cur_idx += 1
	  node = Node(value)
	  node.next = cur.next
	  cur.next = node
	  if node.next is None:
		  self.tail = node

  def remove(self, idx):
	  cur = self.head
	  cur_idx = 0
	  while cur_idx < idx-1:
		  cur = cur.next
		  if cur is None:
			  raise Exception('list length less than index')
		  cur_idx += 1
	  cur.next = cur.next.next
	  if cur.next is None:
		  self.tail = cur

if __name__ == '__main__':
  linked_list = LinkedList()
  for i in range(10):
	  linked_list.append(i)

  linked_list.insert(3, 30)

  linked_list.remove(4)

  for node in linked_list.iter():
	  print(node)

#TODO 判空
#TODO 实现 __len__
 #+END_SRC
** 堆
 #+BEGIN_SRC python
import math
import random


class Heap:
  def __init__(self):
	  self.__data = []

  def insert(self, value):
	  self.__data.append(value)
	  idx = len(self.__data) - 1
	  parent = math.floor((idx - 1) / 2)
	  while parent >= 0 and self.__data[parent] < value:
		  self.__data[idx] = self.__data[parent]
		  self.__data[parent] = value
		  idx = parent
		  parent = math.floor((idx - 1) / 2)

  def pop(self):
	  if not self.__data:
		  raise Exception('Empty')
	  ret = self.__data[0]
	  value = self.__data.pop()
	  self.__data[0] = value
	  idx = 0
	  left = 2 * idx + 1
	  right = 2 * idx + 2
	  while len(self.__data) > left:
		  tmp_idx = left
		  if len(self.__data) > right and self.__data[right] > self.__data[left]:
			  tmp_idx = right
		  if self.__data[tmp_idx] > value:
			  self.__data[idx] = self.__data[tmp_idx]
			  self.__data[tmp_idx] = value
		  else:
			  return ret
		  idx = tmp_idx
		  left = 2 * idx + 1
		  right = 2 * idx + 2
	  return ret

  def remove(self, i):
	  if len(self.__data) - 1 < i:
		  raise Exception('Empty')
	  ret = self.__data[i]
	  value = self.__data.pop()
	  self.__data[i] = value
	  idx = i
	  left = 2 * idx + 1
	  right = 2 * idx + 2
	  while len(self.__data) > left:
		  tmp_idx = left
		  if len(self.__data) > right and self.__data[right] > self.__data[left]:
			  tmp_idx = right
		  if self.__data[tmp_idx] > value:
			  self.__data[idx] = self.__data[tmp_idx]
			  self.__data[tmp_idx] = value
		  else:
			  return ret
		  idx = tmp_idx
		  left = 2 * idx + 1
		  right = 2 * idx + 2
	  return ret

  def view(self):
	  print(self.__data)

if __name__ == '__main__':
  heap = Heap()
  for _ in range(8):
	  i = random.randint(0, 100)
	  print('i is ', i)
	  heap.insert(i)
  heap.view()
  #heap.pop()
  heap.remove(1)
  heap.view()
 #+END_SRC
** 栈
 #+BEGIN_SRC python
class Node:
  def __init__(self, value):
	  self.value = value
	  self.next = None


class Stack:
  def __init__(self):
	  self.top = None

  def push(self, value):
	  node = Node(value)
	  node.next = self.top
	  self.top = node

  def pop(self):
	  node = self.top
	  self.top = node.next
	  return node.value


if __name__ == '__main__':
  stack = Stack()
  exp = '({a * [x/(x+y)]}'
  for c in exp:
	  if c in '{[(':
		  stack.push(c)
	  elif c in '}])':
		  v = stack.top.value
		  if c == '}' and v != '{':
			  raise Exception('failed')
		  if c == ']' and v != '[':
			  raise Exception('failed')
		  if c == ')' and v != '(':
			  raise Exception('failed')
		  stack.pop()
  if stack.top is not None:
	  raise Exception('failed')
  print("ok")
 #+END_SRC
** 树
 #+BEGIN_SRC python
from stack import Stack
from queue import Queue


class Node:
  def __init__(self, value):
	  self.value = value
	  self.left = None
	  self.right = None


class Tree:
  def __init__(self, node):
	  self.root = node

  def add_left(self, tree):
	  self.root.left = tree

  def add_right(self, tree):
	  self.root.right = tree

  @property
  def left(self):
	  return self.root.left

  @property
  def right(self):
	  return self.root.right

  def visit_first(self, fn):
	  fn(self.root.value)
	  if self.left:
		  self.left.visit_first(fn)
	  if self.right:
		  self.right.visit_first(fn)

  def visit_middle(self, fn):
	  if self.left:
		  self.left.visit_middle(fn)
	  fn(self.root.value)
	  if self.right:
		  self.right.visit_middle(fn)

  def visit_last(self, fn):
	  if self.left:
		  self.left.visit_last(fn)
	  if self.right:
		  self.right.visit_last(fn)
	  fn(self.root.value)

  def iter_visit_first(self, fn):
	  stack = Stack()
	  stack.push(self)
	  while stack.top:
		  p = stack.pop()
		  fn(p.root.value)
		  if p.right:
			  stack.push(p.right)
		  if p.left:
			  stack.push(p.left)

  def visit_level(self, fn):
	  queue = Queue()
	  queue.put(self)

	  while not queue.empty():
		  p = queue.get()
		  fn(p.root.value)
		  if p.left:
			  queue.put(p.left)
		  if p.right:
			  queue.put(p.right)


if __name__ == '__main__':
  d = Tree(Node('D'))
  e = Tree(Node('E'))
  b = Tree(Node('B'))
  b.add_left(d)
  b.add_right(e)
  f = Tree(Node('F'))
  g = Tree(Node('G'))
  c = Tree(Node('C'))
  c.add_left(f)
  c.add_right(g)
  a = Tree(Node('A'))
  a.add_left(b)
  a.add_right(c)

  from functools import partial
  p = partial(print, end='')
  a.visit_first(p)
  print()
  a.iter_visit_first(p)
  print()
  a.visit_middle(p)
  print()
  a.visit_last(p)
  print()
  a.visit_level(p)

#TODO 中序、后序便利的非第归方法

# ABDECFG first
# DBEAFCG middle
# DEBFGCA last

# ABCDEFG
 #+END_SRC
** map
 #+BEGIN_SRC python
class Node:
  def __init__(self, key, value):
	  self.key = key
	  self.value = value

  def __eq__(self, other):
	  return self.key == other.key


class Map:
  def __init__(self, init_size, hash=hash):
	  self.__slot = [[] for _ in range(init_size)]
	  # for _ in range(init_size):
	  #     self.__slot.append([])
	  self.__size = init_size
	  self.hash = hash

  def put(self, key, value):
	  node = Node(key, value)
	  address = self.hash(node.key) % self.__size
	  self.__slot[address].append(node)

  def get(self, key, default=None):
	  _key = self.hash(key)
	  address = _key % self.__size
	  for node in self.__slot[address]:
		  if node.key == key:
			  return node.value
	  return default

  def remove(self, key):
	  address = self.hash(key) % self.__size
	  try:
		  self.__slot[address].remove(Node(key, None))
	  except ValueError:
		  pass
	  # for idx, node in enumerate(self.__slot[address].copy()):
	  #     if node.key == key:
	  #         self.__slot[address].pop(idx)


if __name__ == '__main__':
  map = Map(16)

  for i in range(20):
	  map.put(i, i)

  map.remove(3)
  for i in range(20):
	  print(map.get(i, 'not set'))
 #+END_SRC
** 规则解析
 #+BEGIN_SRC python
# #expr# &  | ! ()

# (#e1# & #e2#) |(!#e3# & #e4#)

from stack import Stack
# '(#abc# & #324#) | (!#def# & #789#)'

def match(exprs, line, fn):
  stack = Stack()
  is_expr = False
  expr = []
  for c in exprs:
	  if c == '#':
		  if not is_expr:
			  is_expr = True
		  else:
			  is_expr = False
			  v = fn(line, ''.join(expr))
			  expr = []
			  if stack.top is None:
				  stack.push(v)
				  continue
			  s = stack.pop()
			  if s == '!':
				  v = not v
				  if stack.top is None:
					  stack.push(v)
					  continue
				  s = stack.pop()
			  if s == '&':
				  if isinstance(stack.top.value, bool):
					  v = stack.pop() and v
					  stack.push(v)
				  else:
					  raise Exception('wrong expr')
			  elif s == '|':
				  if isinstance(stack.top.value, bool):
					  v = stack.pop() or v
					  stack.push(v)
				  else:
					  raise Exception('wrong expr')
			  elif s == '(':
				  stack.push(s)
				  stack.push(v)
			  else:
				  raise Exception('wrong expr')
	  else:
		  if is_expr:
			  expr.append(c)
		  else:
			  if c in '(&!|':
				  stack.push(c)
			  elif c.strip() == '':
				  pass
			  elif c == ')':
				  v = stack.pop()
				  if not isinstance(v, bool):
					  raise Exception('wrong expr')
				  s = stack.pop()
				  if s == '!':
					  v = not v
					  s = stack.pop()
				  if s == '(':
					  stack.push(v)
				  else:
					  raise Exception('wrong expr')
			  else:
				  raise Exception('wrong expr')

  while stack.top:
	  v = stack.pop()
	  if not isinstance(v, bool):
		  raise Exception('wrong expr')
	  s = stack.pop()
	  if s == '!':
		  v = not v
		  s = stack.pop()
	  if s == '&':
		  v2 = stack.pop()
		  if not isinstance(v2, bool):
			  raise Exception('wrong expr')
		  v = v and v2
	  elif s == '|':
		  v2 = stack.pop()
		  if not isinstance(v2, bool):
			  raise Exception('wrong expr')
		  v = v or v2
	  else:
		  raise Exception('wrong expr')
	  if stack.top is None:
		  return v
	  else:
		  stack.push(v)

if __name__ == '__main__':
  import re
  line = 'abc 123 def 456 asd 789'
  exprs = '(#abc# & #324#) | (!#def# & #789#)' # False

  def callback(line, expr):
	  return re.match(expr, line) is not None

  print(match(exprs, line, callback))

#TODO 优化两个程序， 使其模块化
 #+END_SRC
** 实现带优先级的算术表达式解析
 #+BEGIN_SRC python
from stack import Stack

func_map = {
  '+': lambda x, y: x+y,
  '*': lambda x, y: x*y,
  '/': lambda x, y: x/y,
  '-': lambda x, y: x-y
}

# (3 + 4) * 5 / ((2+3) *3)
def cacl(expr):
  stack = Stack()
  for c in expr:
	  if c in '(+-*/':
		  stack.push(c)
	  elif c.strip() == '':
		  pass
	  else:
		  if c != ')':
			  c = int(c)
			  if stack.top.value in '+-/*':
				  s = stack.pop()
				  if not isinstance(stack.top.value, (int, float)):
					  raise Exception('wrong expr')
				  v = stack.pop()
				  v = func_map[s](v, c)
				  stack.push(v)
			  else:
				  stack.push(c)
		  if c == ')':
			  if isinstance(stack.top.value, (int, float)):
				  v = stack.pop()
				  if stack.top.value == '(':
					  stack.pop()
					  stack.push(v)
				  else:
					  raise Exception('wrong expr')
			  else:
				  raise Exception('wrong expr')
  while stack.top:
	  c = stack.pop()
	  if not isinstance(c, (int, float)):
		  raise Exception('wrong expr')
	  if stack.top.value in '+-/*':
		  s = stack.pop()
		  if not isinstance(stack.top.value, (int, float)):
			  raise Exception('wrong expr')
		  v = stack.pop()
		  v = func_map[s](v, c)
		  if stack.top is None:
			  return v
		  stack.push(v)
	  else:
		  raise Exception('wrong expr')

if __name__ == '__main__':
  print(cacl('(3 + 4) * 5 / ((2+3) *3)'))

#TODO 实现带优先级的算术表达式解析
 #+END_SRC

 #+RESULTS:

* 简单聊聊
Why：为什么选择Python
Python是一种解释型、面向对象、动态数据类型的高级程序设计语言

Tiobe的趋势
PYPL的趋势
GitHub的开源项目
最赚钱

How：怎么学？
专心看视频，电脑实际操作，做作业，想一想，跟大家分享

What：学什么？
#+BEGIN_SRC python
  #!/usr/bin/env python
  # -*- coding: utf-8 -*-

  # bubble sort algorithm
  def bubble_sort(nums):
	  for j in xrange(len(numbers), -1, -1):
		  for i in xrange(0, j - 1, 1):
			  if nums[i] > nums[i+1]:
				  nums[i], nums[i+1] = nums[i+1], nums[i]

  # test
  if __name__ == '__main__':
	  numbers = [[9, 23, 12, 32, 12], ['2', '3', '3', '6'], ['b', 'a', 'w']]
#+END_SRC
* 内置数据结构
五种内置容器，
1. 列表
2. 元组
3. 字符串
4. 集合
5. 字典

解析式，
1. 列表解析   # Python2只有列表解析
2. 生成器解析 # Python3特有
3. 集合解析   # Python3特有
4. 字典解析   # Python3特有

列表、元组、字符串属于线性结构，我们可以对其进行切片操作、解包/封包操作。
** 字符串
*** 字符串格式化
  两种格式化形式：
  1. printf形式

  2. format方法
*** 转义 r''
  为了避免转义，可以加上r前缀，就表示该字符串是自然字符串，自然字符串不会被转义。
 #+BEGIN_SRC python
s = "C:\newpython", print s, len(s)
r'\n' # 前缀字符串，不考虑转义
s = r"C:\newpython"
 #+END_SRC
*** re模块
**** 正则表达式 
** 字符串与bytes
Python3引入了bytes与bytearray两种数据类型。byte是Python3特有的。
Python2里不区分byte和str。Python3字符串默认使用utf-8编码。

如何定义bytes：
1. bytes可以通过str的encode方法转化得到
2. 通过b前缀定义bytes
#+BEGIN_SRC python :results output :exports both
  b = b'\xe9\xa9\xac'
  print(type(b))
  # bytes
#+END_SRC

#+RESULTS:
: <class 'bytes'>

字符串与bytes的对比：
1. str是文本序列
2. bytes是字节序列
3. string的所有操作bytes都支持

一些理论知识：
+ 文本是有编码的（utf-8，gbk，GB18030等）
+ 字节没有编码这种说法
+ 文本的编码指的是字符如何使用字节来表示
#+BEGIN_SRC python
# python2
type(b'xxx')
type('xxx')
type(u'xxx')
#+END_SRC

#+BEGIN_SRC python
b = b'xxxxx'
b.find(b'x')
0
#+END_SRC
bytes和str的区别在于bytes是byte的序列，而str是unicode的序列。

*str使用encode方法转化为bytes，bytes通过decode转化为str。*
#+BEGIN_SRC python
s = "马哥教育"
b = s.encode()
for x in b:
  print(x)
b.decode() # 默认参数是utf8
for x in b:
  print(x)

# 读取文件
# python3
echo "马哥教育" > utf8.txt
iconv -f UTF-8 -t gbk utf8.txt > gbk.txt
f = open('gbk.txt', 'rb')
buf = f.read()
buf
buf.decode('GBK')
s  = buf.decode('GBK')
s
type(buf)
print(buf)

f.close()
#+END_SRC
其实就是防止产生乱码。

在网络编程里，传输的内容是二进制的内容。如果是不同平台之间进行传输数
据，尽量明确指定encode及decode的编码及解码格式。
*** bytes操作
  除了encode外，str操作，都有对应bytes的版本，但是传入参数也必须是
  bytes。
  #+BEGIN_SRC python :results output :exports both
	b = b'abc'
	# print(b'abc'.find('b')) # 参数必须是bytes，此处会异常
	print(b'abc'.find(b'b')) # 1
	print('马哥教育'.encode().find(b'\xa9')) # 输出1。bytes的操作是按字节的
	print('马哥教育'.encode())
	print(len('马哥教育'.encode()))
	print(b.decode())
	print(b.hex())
  #+END_SRC

  #+RESULTS:
  : 1
  : 1
  : b'\xe9\xa9\xac\xe5\x93\xa5\xe6\x95\x99\xe8\x82\xb2'
  : 12
  : abc
  : 616263

** bytearray
 bytearray是bytes的可变版本。str和bytes是不可变的。
 #+BEGIN_SRC python :results output :exports both
   b = b'abc'
   # b[1] = b'B' # 这里赋值会抛出异常
   b = bytearray(b)
   print(type(b))
   b[1] = int(b'B'.hex(), 16)
   print(b)
 #+END_SRC

 #+RESULTS:
 : <class 'bytearray'>
 : bytearray(b'aBc')

 bytearray是可变的，为什么要可变呢？主要用在图片处理。相对bytes来说，
 多了insert，append，extend，pop，remove，clear，reverse这些方法，这
 些方法都是原地修改的，并且可以索引操作。

 append，insert，remove，count的参数必须是int类型。
** 字典
字典的update方法，
#+BEGIN_SRC python
# 存在相应的key，则更新原来key的value
# 不存在相应的的key，则增加
>>> dict01 = {'laven': 29, 'taoqi': 26}
>>> dict01
{'taoqi': 26, 'laven': 29}

# 使用update增加一个key-value
>>> dict01.update(a=123)
>>> dict01
{'a': 123, 'taoqi': 26, 'laven': 29}

# 使用update更新一个key-value
>>> dict01.update(laven=23)
>>> dict01
{'a': 123, 'taoqi': 26, 'laven': 23}

# 使用update更新字典，参数为一个二元组的列表
>>> dict01.update([('c', 3), ('d', 4)])
>>> dict01.update({'a': 2, 'b': 3}) # 这种形式很少使用
>>> dict01
{'a': 2, 'b': 3, 'taoqi': 26}
#+END_SRC
update的参数可以是以下几种情况：
1. 字典
2. 由二元组构成的可迭代对象
3. 关键字参数

删除字典，
1. pop      # 删除指定，返回key的value
2. popitem  # 随机删除，返回随机删除的一个kv二元组
3. clear    # 清空字典

看几个例子，
#+BEGIN_SRC python
>>> dict01 = {'laven': 29, 'taoqi': 26}

# pop一个存在的key
>>> dict01.pop('laven')
29

# pop一个不存在的key
>>> dict01.pop('a')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'a'

# pop一个不存在的key，返回指定的值
>>> dict01.pop('a', -1)
-1
>>> dict01.popitem()
In [38]: dict0.popitem()
Out[38]: (0, 'abc')
#+END_SRC

字典的访问可以通过key找到其对应的value，也可以通过字典对象的get方法来获得，
#+BEGIN_SRC python
  >>> d = {'a': 1, 'b': 2}
  >>> d
  {'a': 1, 'b': 2}
  >>> d['a']
  1

  # get一个存在的key
  d.get('a')
  1

  # get一个不存在的key返回None
  d.get('c')

  # 给get一个默认值，默认为None
  d.get('c', 123)
  123
  d.setdefault('c', 'default')

  # setdefault方法先调用
  def setdefault(d, k, default=None):
	  value = d.get(k, default)
	  d[k] = value
	  return value
#+END_SRC

遍历字典，
#+BEGIN_SRC python
d = {'a': 1, 'b': 2, 'c': 3}
>>> for item in d:
...  print(item)
... 
a
b
c

>>> d.keys()
dict_keys(['a', 'b', 'c'])

>>> for k in d.keys():
...     print('{} => {}'.format(k, d[k]))
... 
a => 1
b => 2
c => 3

>>> dk = d.keys()
>>> dk
dict_keys(['a', 'b', 'c'])
help(dk)
>>> dk - {'a', 'c'}
{'b'}
>>> dk # dk本身的值没有改变
dict_keys(['a', 'b', 'c'])

>>> dk | {'d'}
{'a', 'b', 'c', 'd'}
>>> dk
dict_keys(['a', 'b', 'c'])

d.values()
for v in d.values():
  print(v)
dv = d.values()
>>> dv
dict_values([1, 2, 3])
help(dv)
Help on dict_values object:

class dict_values(object)
|  Methods defined here:
|  
|  __getattribute__(self, name, /)
|      Return getattr(self, name).
|  
|  __iter__(self, /)
|      Implement iter(self).
|  
|  __len__(self, /)
|      Return len(self).
|  
|  __repr__(self, /)
|      Return repr(self).

>>> d.items()
dict_items([('a', 1), ('b', 2), ('c', 3)])
>>>
help(d.items)

>>> for k, v in d.items():
...     print('{} => {}'.format(k, v))
... 
a => 1
b => 2
c => 3

>>> di = d.items()
>>> di
dict_items([('a', 1), ('b', 2), ('c', 3)])
>>>
help(di) # 也有集合的运算
#+END_SRC

keys，values，items返回的都是生成器，它并不会复制一份内存。而python2
对应的函数返回的是列表，会复制一份。

enumerate方法，
#+BEGIN_SRC python
for k, v in enumerate(d):
  print('{} => {}'.format(k, v))
0 => a
1 => b
2 => c
#+END_SRC

根据value找其对应的key，
#+BEGIN_SRC python
>>> d
{'a': 1, 'b': 2, 'c': 3}
>>> d.update(c=123)
>>> d
{'a': 1, 'b': 2, 'c': 123}
>>> for k, v in d.items():
...     if v == 123:
...         print(k)
...         break
... 
c
#+END_SRC

一个例子，
#+BEGIN_SRC python
for i, (k, v) in enumerate(d.items()):
  print(i, k, v)
#+END_SRC
------------------------------------------------------------------

zip可以将长度相同的两个列表组合成一个字典。

散列表，没有顺序，适合插入，查询操作。

key不一定是字符串，但一定是不可变对象

排序
#+BEGIN_SRC python
[(k, dict[k]) for k in sorted(dict.keys())]
sorted(dict.iteritems(), key=lambda d: d[1], reverse=True)
#+END_SRC

sorted内置方法的用法：
#+BEGIN_SRC python
In [9]: help(sorted)
Help on built-in function sorted in module __builtin__:

sorted(...)
  sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list

In [11]: student_tuples = [
  ...: ...     ('john', 'A', 15),
  ...: ...     ('jane', 'B', 12),
  ...: ...     ('dave', 'B', 10),
  ...: ... ]
  ...:

In [12]: student_tuples
Out[12]: [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

In [13]: sorted(student_tuples, key=lambda student: student[2])
Out[13]: [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

In [14]: class Student:
  ...:     def __init__(self, name, grade, age):
  ...:         self.name = name
  ...:         self.grade = grade
  ...:         self.age = age
  ...:     def __repr__(self):
  ...:         return repr((self.name, self.grade, self.age))
  ...:

In [15]: student_objects = [Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10)]

In [16]: student_objects
Out[16]: [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

In [17]: sorted(student_objects, key=lambda student: student.age)
Out[17]: [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
#+END_SRC

再论不可变对象，上面我们讲了，str是不可变对象，而list是不可变对象。
对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比
如：
#+BEGIN_SRC python
>>> a = ['c', 'b', 'a']
>>> a
['c', 'b', 'a']
>>> a.sort()
>>> a
['a', 'b', 'c']
#+END_SRC

而对于不可变对象，比如str，对str进行操作呢：
#+BEGIN_SRC python
>>> a = 'abc'
>>> a
'abc'
>>> a = a.replace('a', 'A')
>>> a
'abc'
#+END_SRC
虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？
我们先把代码改成下面这样：
#+BEGIN_SRC python
>>> a = 'abc'
>>> a
'abc'
>>> b = a.replace('a', 'A')
>>> b
'Abc'
>>> a
'abc'
#+END_SRC

要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，
对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容
才是'abc'。当我们调用a.replace('a', 'A')时，实际上调用方法replace是
作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变
字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，
如果我们用变量b指向该新字符串，就容易理解了，变量a仍然指向原有的字符
串'abc'，但变量b却指向新字符串'Abc'了。

所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身
的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象
本身永远是不可变的。
*** 默认字典
  #+BEGIN_SRC python :results output code :exports both
	from collections import defaultdict

	d1 = {}

	print(d1)

	d2 = defaultdict(list)
	print(d2)

	print(d1['a'])

	print(d2['a'])
  #+END_SRC

#+RESULTS:
#+BEGIN_SRC python
#+END_SRC
  default初始化的时候，需要传入一个函数，这个函数也叫工厂函数。当我
  们使用下标访问一个key的时候，如果这个key不存在，defaultdict会自动
  调用初始化时传入的函数，生成一个对象作为这个key的value。
  #+BEGIN_SRC python
	from collections import defaultdict

	d = {}

	for k in range(10):
		for v in range(10):
			if k not in d.keys():
				d[k] = []
			d[k].append(v)

	d = defaultdict(list)

	for k in range(10):
		for v in range(10):
			d[k].append(v)
  #+END_SRC

  再来看一个默认字典的例子：
  #+BEGIN_SRC python :results output code :exports both
	from collections import defaultdict


	def f():
		print('f is called')
		return 'a'

	d = defaultdict(f)
	d['xxx']
	d['yyy']
  #+END_SRC

#+RESULTS:
#+BEGIN_SRC python
f is called
f is called
#+END_SRC

*** 有序字典
  有序字典会保持插入顺序。
  #+BEGIN_SRC python :results output code :exports both
	from collections import OrderedDict
	d = OrderedDict()
	d[0] = 3
	d[3] = 4
	d[1] = 5
	print(d)

	for k, v in d.items():
		print(k, v)
  #+END_SRC

#+RESULTS:
#+BEGIN_SRC python
OrderedDict([(0, 3), (3, 4), (1, 5)])
0 3
3 4
1 5
#+END_SRC
*** 常用操作
  + keys, values
  + get
  + del
  + clear
  + 嵌套
*** 引用和拷贝
  字典D.copy(), copy.copy(D)
  列表L[:]

  深拷贝 - 一个新的对象
  copy.deepcopy(D)
*** 字典的限制
  字典的key不能重复。字典的key需要可hash。
*** 字典是如何实现的（拓展）
  1. 拉链法
  2. 开地址法
**** 拉链法
   使用一般的方法实现：
   #+BEGIN_SRC python :results output code :exports both
	 slots = []
	 slots_num = 32

	 for _ in range(slots_num):
		 slots.append([])


	 def put(slots, key, value):
		 i = hash(key) % slots_num
		 p = -1
		 for i, (k, v) in enumerate(slots[i]):
			 if k == key:
				 break
		 else:
			 slots[i].append((key, value))
			 return
		 if p >= 0:
			 slots[i][p] = (key, value)


	 def get(slots, key):
		 i = hash(key) % slots_num
		 for k, v in slots[i]:
			 if k == key:
				 return v
		 raise KeyError(k)

	 put(slots, 'a', 2)
	 print(slots)
	 put(slots, 'b', 3)
	 print(slots)
   #+END_SRC

#+RESULTS:
#+BEGIN_SRC python
[[], [], [], [], [], [], [], [], [], [], [], [], [], [('a', 2)], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []]
[[], [], [], [], [], [], [], [], [], [], [], [], [], [('a', 2)], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [('b', 3)]]
#+END_SRC

   如何操作：
   #+BEGIN_SRC python
put(slots, 'a', 2)
put(slots, 'b', 3)
slots
   #+END_SRC

   使用类来实现：
   #+BEGIN_SRC python
	 class Dict:
		 def __init__(self, slot_number):
			 self.slot_number = slot_number
			 self.slots = []
			 for _ in range(slot_number):
				 self.slots.append([])

		 def put(self, key, value):
			 idx = hash(key) % self.slot_number
			 self.slots[idx].append((key, value))

		 def get(self, key):
			 idx = hash(key) % self.slot_number
			 for k, v in self.slots[idx]:
				 if key == k:
					 return v
			 raise KeyError(key)

		 def keys(self):
			 ret = []
			 for slot in self.slots:
				 for k, _ in slot:
					 ret.append(k)
			 return ret

	 my_dict = Dict(16)
	 for x in range(20):
		 my_dict.put(str(x), x)
	 my_dict.get('0')
	 my_dict.get('20')
	 my_dict.get('19')
   #+END_SRC
**** 开地址法
   开地址法与拉链法类似：
   #+BEGIN_SRC python
class Set:
  def __init__(self, slot_number):
	  self.slot_number = slot_number
	  self.slots = []
	  for _ in range(slot_number):
		  self.slots.append([])

  def add(self, key):
	  idx = hash(key) % self.slot_number
	  self.slots[idx].append((key, value))

  def get(self, key):
	  idx = hash(key) % self.slot_number
	  for k, v in self.slots[idx]:
		  if key == k:
			  return value
	  raise KeyError(key)
   #+END_SRC
* 递归
要了解递归，还是要从菲波那切数列说起，菲波那切数列的定义为：
#+BEGIN_EXAMPLE
f(0) = 1
f(1) = 1
f(n) = f(n-1) + f(n-2)
#+END_EXAMPLE

拓展：菲波那切数列的应用。

接下来，用Python来计算斐波那契数列：
#+BEGIN_SRC python
def fib(n):
  if n == 0:
	  return 1
  if n == 1:
	  return 1
  return fib(n-1) + fib(n-2)
fib(5)
fib(10)
#+END_SRC

阶乘问题也需要用到递归。
#+BEGIN_SRC sh
g(0) = 1
g(1) = 1
g(n) = n*g(n-1)
#+END_SRC

用代码表示：
#+BEGIN_SRC python
def g(n):
  if n == 0:
	  return 1
  if n == 1:
	  return 1
  return n*g(n-1)
g(5)
123
#+END_SRC

递归函数总是涉及到压栈和出栈的过程。递归函数总是压栈直到遇到退出条件，
然后出栈。

Python中的递归是有限制的，其递归深度最大深度为1000，验证：
#+BEGIN_SRC python
import sys

sys.getrecursionlimit()
#+END_SRC
既然有getrecursionlimit方法，有没有setrecursionlimit方法呢？
#+BEGIN_SRC python
import sys
sys.setrecursionlimit(10000)
g(1000)
#+END_SRC
* 函数
Python中，参数总是引用传递。

一切皆对象。所有对象都是引用。

值保存在栈空间，引用保存在堆空间。

函数是Python的最小作用域，组织代码的最小单元。

函数没有显式的return语句时，默认返回None。

函数只能返回一个值，如果return语句后面有多个逗号分隔的值，会自动的封
包成一个元组。

一个函数不能有多个return语句。函数遇到第一个return语句就返回了。执行
return语句，会返回到调用方的作用域，函数的作用域就被销毁了（垃圾回
收）。

#+BEGIN_SRC python :results output :exports both
  def add(x, y): # 函数定义def表示定义一个函数，紧接着是函数名，函数名后面用一对小括号列出参数，参数列表后面
	  ret = x + y
	  print('{} + {} = {}'.format(x, y, ret))
	  return x + y

  add(3, 5)

  add(y=3, x=5)
#+END_SRC

#+RESULTS:
: 3 + 5 = 8
: 5 + 3 = 8

定义函数时并不会执行函数体，当调用函数的时候，才会执行其中的语句块。
** 函数执行流程
 所有的变量都在堆里面。

 遇到函数调用就把函数压栈。

 当调用函数的时候，解释器会把当前现场压栈，然后开始执行被调函数，被
 调函数执行完毕，解释器弹出当前栈顶，恢复现场。
** 调用函数
 Python内置了很多有用的函数，我们可以直接使用。要调用一个函数，需要
 知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接
 从Python的官方网站查看文档：
 #+BEGIN_SRC sh
http://docs.python.org/2/library/functions.html#abs
 #+END_SRC

 也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。

 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，
 相当于给这个函数起了一个“别名”：
 #+BEGIN_SRC python
>>> a = abs
>>> a(-1)
1
 #+END_SRC

 调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出
 错，一定要学会看错误信息，所以英文很重要！
** 定义函数
 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中
 的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句
 返回。

 我们以自定义一个绝对值的my_abs函数为例：
 #+BEGIN_SRC python
   def my_abs(x):
	   if x >= 0:
		   return x
	   else:
		   return -x
 #+END_SRC

 接下来调用该函数，并验证该函数的正确性，
 #+BEGIN_SRC python
>>> my_abs(-10)
10
 #+END_SRC

 根据输出结果应该是没有问题的。

 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。
 因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。

 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。
 return None可以简写为return。
*** 空函数
  如果想定义一个什么事也不做的空函数，可用pass语句：
  #+BEGIN_SRC python
def nop():
  pass
  #+END_SRC

  pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如
  现在还没有想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。pass还可以用在其他语句里，比如：
  #+BEGIN_SRC python
if age >= 18:
  pass
  #+END_SRC
  缺少了pass，代码运行就会有语法错误。
*** 参数检查
  调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：
  #+BEGIN_SRC python
>>> my_abs(1, 2)
Traceback (most recent call last):
File "<pyshell#48>", line 1, in <module>
  my_abs(1, 2)
TypeError: my_abs() takes 1 positional argument but 2 were given
>>>
  #+END_SRC

  但如果参数类型不对，Python解释器就无法帮助我们检查。试试my_abs和内置函数abs的差别：
  #+BEGIN_SRC python
>>> my_abs('A')
'A'
>>> abs('A')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'str'
>>> 
  #+END_SRC

  当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的
  my_abs没有参数检查，所以，这个函数定义不够完善。

  让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类
  型的参数。数据类型检查可以用内置函数isinstance实现：
  #+BEGIN_SRC python
def my_abs(x):
  if not isinstance(x, (int, float)):
	  raise TypeError('bad operand type')
  if x >= 0:
	  return x
  else:
	  return -x
  #+END_SRC

  添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：
  #+BEGIN_SRC python
>>> my_abs('A')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<stdin>", line 3, in my_abs
TypeError: bad operand type
>>>
  #+END_SRC

  错误和异常处理将在后续讲到。
*** 返回多个值
  函数可以返回多个值吗？答案是肯定的。

  比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，
  就可以计算出新的坐标：
  #+BEGIN_SRC python
import math

def move(x, y, step, angle=0):
  nx = x + step * math.cos(angle)
  ny = y - step * math.sin(angle)
  return nx, ny
  #+END_SRC
  这样我们就可以同时获得返回值：
  #+BEGIN_SRC python
>>> x, y = move(100, 100, 60, math.pi / 6)
>>> print x, y
151.961524227 70.0
  #+END_SRC

  但其实这只是一种假象，Python函数返回的仍然是单一值：
  #+BEGIN_SRC python
>>> r = move(100, 100, 60, math.pi / 6)
>>> print r
(151.96152422706632, 70.0)
>>> 
  #+END_SRC

  总结：
  1. 定义函数时，需要确定函数名和参数个数；
  2. 如果有必要，可以先对参数的数据类型做检查；
  3. 函数体内部可以用return随时返回函数结果；
  4. 函数执行完毕也没有return语句时，自动return None；
  5. 函数可以同时返回多个值，但其实就是一个tuple。
** 函数返回值
 return语句除了返回值之外，还会结束函数，return之后的语句将不会被执行。
 #+BEGIN_SRC python :resultsff output :exports both
   def add(x, y):
	   return x + y
	   print('hehe')
 #+END_SRC

 #+RESULTS:
 : None

 一个函数可以有多个return语句，执行到哪个return由哪个return返回结果
 并结束函数。
 #+BEGIN_SRC python :results output :exports both
   def guess(x):
	   if x > 3:
		   return '> 3'
	   return '<= 3'

   guess(3)
   guess(5)
 #+END_SRC

 #+RESULTS:

 再来看一个例子，
 #+BEGIN_SRC python :results output :exports both
   def fn(x):
	   for i in range(x):
		   if i > 3:
			   return i
	   else:
		   print('not bigger than 3')

   fn(10)
 #+END_SRC

 #+RESULTS:

 如果函数没有return语句呢？
 #+BEGIN_SRC python :results output :exports both
   def fn():
	   pass

   ret = fn()
   print(ret)
   print(type(ret))
 #+END_SRC

 #+RESULTS:
 : None
 : <class 'NoneType'>

 当函数没有return语句的时候，返回None。return None与return返回语句是
 等价的，通常用于结束函数。
** 函数嵌套
 函数可以嵌套定义。
 #+BEGIN_SRC python :results output :exports both
   def outter():
	   def inner():
		   print('inner')
	   print('outer')
	   inner()

   outter()
 #+END_SRC

 #+RESULTS:
 : outer
 : inner

** 函数作用域
 作用域是一个变量的可见范围，叫做这个变量的作用域。
 #+BEGIN_SRC python :results output :exports both :session
   # 定义在全局作用域中
   x = 1


   def inc():
	   """
	   函数内部是一个局部作用域
	   """
	   x += 1

   inc()
 #+END_SRC

 #+RESULTS:
 #+begin_example
 inc()
 Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   File "<stdin>", line 5, in inc
 UnboundLocalError: local variable 'x' referenced before assignment
 #+end_example

 再看一个例子：
 #+BEGIN_SRC python :results output :exports both
   def fn():
	   xx = 1 # 上级作用域对下级作用域只读可见
	   print(xx)
	   def inner():
		   xx = 2 # 赋值即定义，在下级作用域里面，重新定义了xx
	   inner()
	   print(xx)

   fn()
 #+END_SRC

 #+RESULTS:
 : 1
 : 1

 作用域总结：
 1. 变量的作用域为
 2. 上级的作用域对下级作用域是只读可见
 3. 赋值即定义
 4. 不同作用域变量不可见，但是下级作用域可以对上级作用域的变量只读可见
*** global全局变量
  #+BEGIN_SRC python :results output :exports both
	xx = 1
	def fn():
		global xx # 可以提升变量作用域为全局变量
		xx += 1

	fn()
	print(xx)
  #+END_SRC

  #+RESULTS:
  : 2

  如果只是使用global提升变量，但并没有赋值呢？
  #+BEGIN_SRC python :results output :exports both :session
	def fn():
		global zz

	fn()
	print(zz)
  #+END_SRC

#+RESULTS:
#+begin_example
def fn():
global zz

fn()
print(zz)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
NameError: name 'zz' is not defined


#+end_example

  再来看一个例子，
  #+BEGIN_SRC python :results output :exports both :session
	def fn():
		global zz
		zz = 3
		print(zz)

	def fn2():
		zz += 1
		print(zz)

	fn()

	fn2()
  #+END_SRC

#+RESULTS:
#+begin_example
def fn():
global zz
zz = 3
print(zz)

def fn2():
zz += 1
print(zz)

fn()
3

fn2()
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "<stdin>", line 2, in fn2
UnboundLocalError: local variable 'zz' referenced before assignment


#+end_example

  global的提升只对本作用域有用，如果要在其他非全局作用域使用，也需要
  做同样的提升。

  对上面的例子进行修改，在fn2函数中使用global，
  #+BEGIN_SRC python :results output :exports both
	def fn():
		global zz
		zz = 3
		print(zz)

	def fn2():
		global zz
		zz += 1
		print(zz)

	fn()

	fn2()
  #+END_SRC

#+RESULTS:
: 3
: 4

  一个闭包的例子：
  #+BEGIN_SRC python :results output :exports both
	def counter():
		c = [0]
		def inc():
			c[0] += 1
  #+END_SRC

*** nonlocal关键字
  #+BEGIN_SRC python :results output :exports both :session
	def counter():
		x = 0
		def inc():
			nonlocal x # nonlocal关键字用于标记
			x += 1
			return x
		return inc

	f = counter()
	f()
  #+END_SRC

  #+RESULTS:
  : f = counter()
  : f()
  : 1

  如果上级作用域没有定义此变量的话，会抛出语法错误。

  对上级作用域的变量可写，使用nonlocal。

  全局变量总结：
  1. 提升只是标记，并没有定义变量，还需要在某处定义变量
  2. 除非你清楚的知道global会带来什么，并且明确的知道非global不行，否则不要使用global
*** 默认参数作用域
  函数也是对象，参数是函数对象的属性，所以函数参数的作用域伴随函数整
  个生命周期。

  使用不可变类型做为默认值。函数体内不改变默认值。
  #+BEGIN_SRC python :results output :exports both
	def fn(lst=None):
		if lst is None:
			lst = []
		lst.append(3)
		print(lst)
	print(fn.__defaults__)
	fn()
	fn()
  #+END_SRC

  #+RESULTS:
  : (None,)
  : [3]
  : [3]

** 递归函数
 Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的
 问题。为了保护解释器，Python对最大递归深度有限制。
 #+BEGIN_SRC python :results output :exports both
   import sys
   print(sys.getrecursionlimit())
 #+END_SRC

 #+RESULTS:
 : 1000

** 匿名函数
** 高阶函数
返回函数或者参数是函数的函数，就可以称为高阶函数。

高阶函数（Higher-order function）。函数是一等对象。

函数也是对象，并且它可以像普通对象一样赋值，作为参数，作为返回值。

#+BEGIN_SRC python :results output :exports both
def counter(base):
	def inc(x=1):
		nonlocal base
		base += x
		return base
	return inc

inc = counter(3)
print(inc(3))
#+END_SRC

#+RESULTS:
: 6

变量可以指向函数，以Python的abs函数为例，
 #+BEGIN_SRC python
abs(-10)
10
 #+END_SRC
但是，如果只写abs呢？
 #+BEGIN_SRC python
>>> abs
<built-in function abs>
 #+END_SRC

可见，abs(-10)是函数调用，而abs是函数本身。要想获得函数调用结果，我们可以把结果赋值给变量：
 #+BEGIN_SRC python
>>> x = abs(-10)
>>> x
10
 #+END_SRC

但是，如果把函数本身赋值给变量呢？
 #+BEGIN_SRC python
>>> f = abs
>>> f
<built-in function abs>
 #+END_SRC

结论：函数本身也可以赋值给变量，即：变量可以指向函数。如果一个变量指向了一个函数，那么，可以通过该变量来调用这个函数，
 #+BEGIN_SRC python
>>> f = abs
>>> f(-10)
10
 #+END_SRC
*** 函数名也是变量
函数名其实就是指向函数的变量。对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个计算绝对值的函数。当然，我们也可以把abs指向	其他对象，但不建议这么做。
*** 传入函数
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称为之为高阶函数。

一个最简单的高阶函数，
  #+BEGIN_SRC python
def add(x, y, f):
  return f(x) + f(y)
  #+END_SRC

当我们调用add(-5, 6, abs)时，参数x，y，和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：
  #+BEGIN_SRC sh
x ==> -5
y ==> 6
f ==> abs
f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
  #+END_SRC

  用代码验证一下：
  #+BEGIN_SRC python
>>> add(-5, 6, abs)
11
  #+END_SRC

编写高阶函数，就是让函数的参数能够接收别的函数。把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。
*** 几个实例
  #+BEGIN_SRC python
def sort(lst, cmp=None, reverse=False):
  def default_cmp(a, b):
	  if a > b:
		  return 1
	  if a == b:
		  return 0
	  if a < b:
		  return -1
  if cmp is None:
	  cmp = default_cmp
  dst = []
  for n in lst:
	  for i, e in enumerate(dst):
		  if not reverse:
			  if cmp(n, e) < 0:
				  dst.insert(i, n)
				  break
		  else:
			  if cmp(n, e) > 0:
				  dst.insert(i, n)
				  break
	  else:
		  dst.append(n)
  return dst
sort([3, 5, 2, 4, 1, 7])
  #+END_SRC

函数作为返回值：通常是用于闭包的场景，需要封装一些变量。

函数作为参数：通常用于大多数逻辑固定，少部分逻辑不固定的场景。

再来看一例：
  #+BEGIN_SRC python
def make_counter(init):
  coutner = [init]
  def inc():
	  coutner[0] += 1
  def dec():
	  coutner[0] -= 1
  def get():
	  return coutner[0]
  def reset():
	  coutner[0] = init
  return inc, dec, get, reset

inc, dec, get, reset = make_counter(0)
inc()
get()
dec()
get()
inc()
inc()
inc()
get()
reset()
# 这个就是所谓的闭包
# Python2中需要使用上述的形式，才能实现闭包
  #+END_SRC

满足以下两点的任意一点：
1. 参数是函数
2. 返回值是函数
都可以称之为高阶函数。

上面的函数重新修改如下，看能否执行：
  #+BEGIN_SRC python
def make_counter(init):
  coutner = init
  def inc():
	  coutner += 1
  def dec():
	  coutner -= 1
  def get():
	  return coutner
  def reset():
	  coutner = init
  return inc, dec, get, reset

inc, dec, get, reset = make_counter(0)
inc()
# 会报错
def make_counter(init):
  coutner = init
  def inc():
	  nonlocal counter
	  coutner += 1
  def dec():
	  nonlocal coutner
	  coutner -= 1
  def get():
	  nonlocal coutner
	  return coutner
  def reset():
	  nonlocal coutner
	  coutner = init
  return inc, dec, get, reset

inc, dec, get, reset = make_counter(0)
  #+END_SRC

介绍一个标准库的一个partial方法，
  #+BEGIN_SRC python
from functools import partial
hex_to_int = partial(int, base=16)
hex_to_int('0xAAAA')
# 偏函数能把函数的参数固定下来
  #+END_SRC

  介绍柯里化，
  #+BEGIN_SRC python
def add(x, y):
  return x + y

# 还可以写成这样
def add(x):
  def add(y):
	  return x + y
  return add
add(3)(5)
  #+END_SRC

partial函数用于固定函数中一个或若干个参数。函数作为参数，对这个作为参数的函数的参数列表是有限的。固定参数通常固定后面的参数。
** 返回函数
 返回函数或者参数是函数的函数 -- 高阶函数。

 Python中的函数是一等对象。函数也是对象，并且它可以像普通对象一样赋
 值，作为参数或返回值。

 #+BEGIN_SRC python
   #!/usr/bin/env python

   def cacl2(s):
	   """
	   def f_add(a, b): return a + b
	   def f_mul(a, b): return a * b
	   def f_sub(a, b): return a - b
	   """

	   if s == '+':
		   return lambda a, b: a + b
	   if s == '*':
		   return lambda a, b: a * b
	   if s == '-':
		   return lambda a, b: a - b
	   else:
		   assert False, "error: operator not defined"

   # 可以使用字典的形式
   calc_dict = {
	   '+': lambda a, b: a + b,
	   '*': lambda a, b: a * b,
	   '-': lambda a, b: a - b,
   }
 #+END_SRC

 高阶函数的例子，
 #+BEGIN_SRC python :results output :exports both
   def sort(iterator, cmp=lambda a, b: a < b):
	   ret = []
	   for x in iterator:
		   for i, e in enumerate(ret):
			   if cmp(x, e):
				   ret.insert(i, x)
				   break
		   else:
			   ret.append(x)
	   return ret

   print(sort([1, 3, 2, 4, 6, 8, 5], lambda a, b: a > b))
 #+END_SRC

 #+RESULTS:
 : [8, 6, 5, 4, 3, 2, 1]

 上述例子是逆序输出，如果我们要顺序输出，那么就要修改上述代码。

 使用场景：
 1. 函数作为返回值：通常是用于闭包的场景，需要封装一些变量
 2. 函数作为参数：通常用于大多数逻辑固定，少部分逻辑不固定的场景
 3. 函数作为参数，返回值也是函数：通常用于作为参数函数执行前后需要一些额外操作（装饰器）

 同时使用上述两种场景的例子：
 #+BEGIN_SRC python :results output :exports both
   def logger(fn):
	   def wrap(*args, **kwargs):
		   print('call {}'.format(fn.__name__))
		   ret = fn(*args, **kwargs)
		   print('{} called'.format(fn.__name__))
		   return ret
	   return wrap

   def add(x, y):
	   return x + y

   logged_add = logger(add)
   logged_add(3, 5)
 #+END_SRC

 #+RESULTS:
 : call add
 : add called

 再来一个例子：
 #+BEGIN_SRC python :results output :exports both
   import time
   import datetime


   def logger(fn):
	   def wrap(*args, **kwargs):
		   start = datetime.datetime.now()
		   ret = fn(*args, **kwargs)
		   end = datetime.datetime.now()
		   print('call {} took {}.'.format(fn.__name__, end - start))
		   return ret
	   wrap.__name__ = fn.__name__
	   wrap.__doc__ = fn.__doc__
	   return wrap


   @logger
   def sleep(x):
	   time.sleep(x)

   print(sleep.__name__)
 #+END_SRC

 #+RESULTS:
 : sleep

 针对上面的例子，我们可以把如下的部分封装为一个函数，
 #+BEGIN_SRC python
   wrap.__name__ = fn.__name__
   wrap.__doc__ = fn.__doc__   
 #+END_SRC

 定义copy_properties函数，
 #+BEGIN_SRC python
   def copy_properties(src, dst):
	   dst.__name__ = src.__name__
	   dst.__doc__ = src.__doc__
 #+END_SRC

 最后，上面的代码可以改写为：
 #+BEGIN_SRC python :results output :exports both
   import time
   import datetime


   def copy_properties(src, dst):
	   dst.__name__ = src.__name__
	   dst.__doc__ = src.__doc__


   def logger(fn):
	   def wrap(*args, **kwargs):
		   start = datetime.datetime.now()
		   ret = fn(*args, **kwargs)
		   end = datetime.datetime.now()
		   print('call {} took {}.'.format(fn.__name__, end - start))
		   return ret
	   copy_properties(fn, wrap)
	   return wrap
 #+END_SRC

 使用一个多余函数copy_properties是不是有些繁琐？还好标准库给我们提供
 了方便的方法，这里我们使用functools库提供的wraps方法，上面的代码改
 写如下：
 #+BEGIN_SRC python :results output :exports both
   import time
   import datetime
   import functools


   def logger(fn):
	   @functools.wraps(fn)
	   def wrap(*args, **kwargs):
		   start = datetime.datetime.now()
		   ret = fn(*args, **kwargs)
		   end = datetime.datetime.now()
		   print('call {} took {}.'.format(fn.__name__, end - start))
		   return ret
	   return wrap


   @logger
   def sleep(x):
	   time.sleep(x)


   print(sleep.__name__)
 #+END_SRC

 #+RESULTS:
 : sleep

** 回调函数
 函数作为参数
 #+BEGIN_SRC python :results output :exports both
   def test(callback):
	   print('test func begin')
	   callback()
	   print('test func end')


   def cb1():
	   print('callback 1')


   def cb2():
	   print('callback 2')


   test(cb1)
   test(cb2)
 #+END_SRC

 #+RESULTS:
 : test func begin
 : callback 1
 : test func end
 : test func begin
 : callback 2
 : test func end

 一个例子：
 #+BEGIN_SRC python :results output :exports both
   def test(callback):
	   print('test func begin')
	   callback()

   def test1(callback):
	   print('test1 func begin')
	   for func in callback:
		   func()

   def cb1():
	   print('callback 1')


   def cb2():
	   print('callback 2')


   if __name__ == '__main__':
	   test(cb1)
	   test(cb2)
	   test1([cb1, cb2])
 #+END_SRC

 #+RESULTS:
 : test func begin
 : callback 1
 : test func begin
 : callback 2
 : test1 func begin
 : callback 1
 : callback 2


 一个应用场景：不同顾客有不同的响应要求
 + 有的顾客通知要发邮件
 + 有的顾客通知要发QQ
 + 有的要发微信
 + 有的要短信

 要求： 文本文件，注册一个通知方式，一个地址，注册后通知消息就跟已注
 册的一起发送。
 #+BEGIN_SRC python :results output :exports both
   def send_weixin(addr, message):
	   print(u"发微信(" + message + u")给" + addr)


   def send_email(addr, message):
	   print(u"发邮件(" + message + u")给" + addr)


   def send_qq(addr, message):
	   print(u"发QQ(" + message + u")给" + addr)


   def send_msm(addr, message):
	   print(u"发短信(" + message + u")给" + addr)


   send_method = {
	   'QQ': send_qq,
	   'WeiXin': send_weixin,
	   'DuanXin': send_msm,
	   'Email': send_email
   }


   """
   def gupiao(f, message, custom_file, vip=False):
	   # 处理message
	   # 判断是否是VIP
	   # 解析文件，得到地址
	   # f(message, addr)
	   pass

   gupiao(send_method['QQ'], message, file_qq)
   gupiao(send_method['WeiXin'], message, file_weixin)
   gupiao(send_method['DuanXin'], message, file_duanxin)
   gupiao(send_method['Email'], message, file_email)
   """


   def gupiao(message, custom_file, vip=False):
	   send_s = []
	   for s in message:
		   if vip == False:
			   t = s.split(',')
			   send_s.append(t[0])
		   else:
			   send_s.append(s)

	   send_message = ';'.join(send_s)

	   # callback
	   for line in open(custom_file, 'r'):
		   info = line.strip().split(',')
		   send_method[info[0]](info[1], send_message)

   if __name__ == '__main__':
	   gupiao([u"000001买,低于8.5买", u"000002卖,高于11.2卖"], 'custom_file.txt')
	   print('####### VIP #######')
	   gupiao([u"000001买,低于8.5买", u"000002卖,高于11.2卖"], 'custom_file.txt', vip=True)
 #+END_SRC

 #+RESULTS:

 所需的顾客的信息：
 #+BEGIN_EXAMPLE
 # file_name: custom_file.txt
 QQ, 13242882, chenxiansheng
 WeiXin, airman, liuxiansheng
 DuanXin, 13166668888, wangxiaojie
 Email, 111@163.com, zhanglingdao
 #+END_EXAMPLE
** 闭包closure
 绑定外部变量的函数。

 闭包closure：
 1. 嵌套函数
 2. 内部函数用到了外部变量（通常是外部函数的参数）
 3. 外部函数返回内部函数

 #+BEGIN_SRC python :results output :exports both
   def pow_x(x):
	   def echo(value):
		   return value ** x
	   return echo

   lst = [pow_x(2), pow_x(3), pow_x(4)]
   for p in lst:
	   print(p(2))
 #+END_SRC

 #+RESULTS:
 : 4
 : 8
 : 16

 1. 内部函数不能“改变”外部变量
 2. 内部函数用到了外部变量为list，则可以从外部或内部改变值，并且即使
	外部没有引用也不会回收
** 偏函数
* 日期和时间
** datetime
** time
 datetime.time(16, 10, 10)
 time.time() # 实际时间
 time.clock() # CPU时间
 time.sleep() # 以秒为单位
** 一个例子
* 作用域
locals()函数列出当前作用域内的所有变量。
** 全局作用域
 1. 函数之外的
 2. 参数列表里的
** 函数作用域
 1. 函数内定义的
* 高级特性
** 切片
 取一个list或tuple的部分元素是非常常见的操作。如一个list为，
 #+BEGIN_SRC python
L = ['Lavenliu', 'Taoqi', 'James', 'Wade', 'Bosh']
 #+END_SRC
 取出前3个元素，
 #+BEGIN_SRC python
>>> L[0], L[1], L[2]
('Lavenliu', 'Taoqi', 'James')
 #+END_SRC

 也可以使用如下的方法，
 #+BEGIN_SRC python
>>> r = []
>>> n = 3
>>> for i in range(n):
...     r.append(L[i])
... 
>>> r
['Lavenliu', 'Taoqi', 'James']
 #+END_SRC

 如果使用了python提供的切片操作，将会非常的简单，
 #+BEGIN_SRC python
>>> L[0:3]
['Lavenliu', 'Taoqi', 'James']
 #+END_SRC

 L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，
 2，正好是3个元素如果第一个索引是0，还可以省略：
 #+BEGIN_SRC python
>>> L[:3]
['Lavenliu', 'Taoqi', 'James']
 #+END_SRC

 也可以从索引1开始，取出2个元素出来：
 #+BEGIN_SRC python
>>> L[1:3]
['Taoqi', 'James']
 #+END_SRC

 Python也支持倒数切片，倒数的第一个元素的索引是-1。
 #+BEGIN_SRC python
>>> L[-1]
'Bosh'
>>> L[-2:]
['Wade', 'Bosh']
 #+END_SRC

 通过切片可以轻松取出某一序列，比如取出前3个及后3个，
 #+BEGIN_SRC python
>>> L[:3]
['Lavenliu', 'Taoqi', 'James']
>>> L[-3:]
['James', 'Wade', 'Bosh']
 #+END_SRC

 #+BEGIN_SRC python
>>> L = range(50)
>>> L
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 
38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]
 #+END_SRC

 前10个数，每2个取一个，
 #+BEGIN_SRC python
>>> L[:10:2]
[0, 2, 4, 6, 8]
 #+END_SRC

 所有数，每5个取一个，
 #+BEGIN_SRC python
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]
 #+END_SRC

 甚至什么都不写，只写[:]就可以原样复制一个list：
 #+BEGIN_SRC python
>>> L[:]
[0, 1, 2, 3, 4, 5, 6, 7, ..., 49]
 #+END_SRC

 tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
 #+BEGIN_SRC python
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
 #+END_SRC

 字符串'xxx'或Unicode字符串u'xxx'也可以看成是一种list，每个元素就是
 一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
 #+BEGIN_SRC python
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'
 #+END_SRC

 在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对
 字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可
 以完成，非常简单。

 有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行
 代码就可以实现很多行循环才能完成的操作。
** 迭代
 如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，
 这种遍历我们称为迭代（Iteration）。Python的for循环不仅可以用在list
 或tuple上，还可以作用在其他可迭代对象上。

 list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，
 只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：
 #+BEGIN_SRC python
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> for key in d:
...     print key
...
a
c
b
 #+END_SRC

 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in
 d.itervalues()，如果要同时迭代key和value，可以用for k, v in
 d.iteritems()。

 由于字符串也是可迭代对象，因此，也可以作用于for循环：
 #+BEGIN_SRC python
>>> for ch in 'ABC':
...     print ch
...
A
B
C
 #+END_SRC

 所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以
 正常运行，而我们不太关心该对象究竟是list还是其他数据类型。那么，如
 何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类
 型判断：
 #+BEGIN_SRC python
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
 #+END_SRC

 最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？
 Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以
 在for循环中同时迭代索引和元素本身：
 #+BEGIN_SRC python
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print i, value
...
0 A
1 B
2 C
 #+END_SRC

 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：
 #+BEGIN_SRC python
>>> for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print x, y
...
1 1
2 4
3 9
 #+END_SRC

 任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符
 合迭代条件，就可以使用for循环。
* IO与文件操作
** open函数与mode
 文件对象维持一个指针，指向当前所操作的位置，下一次操作，会从这个位置开始。

 要改变指针的位置，使用文件对象的seek()方法来改变。
 #+BEGIN_SRC python
read()     # 读入文件对象的所有数据
read(N)    # 读入文件对象当前指针位置的N个字节
 #+END_SRC

 read()函数接收一个参数size，返回从当前指针位置开始的size个字符，

 *返回读取的字符串。* 此话有问题

 open函数的mode，
 | Character | Meaning                                                         |
 |-----------+-----------------------------------------------------------------|
 | 'r'       | open for reading (default)                                      |
 | 'w'       | open for writing, truncating the file first                     |
 | 'x'       | create a new file and open it for writing                       |
 | 'a'       | open for writing, appending to the end of the file if it exists |
 | 'b'       | binary mode                                                     |
 | 't'       | text mode (default)                                             |
 | '+'       | open a disk file for updating (reading and writing)             |

  #+BEGIN_EXAMPLE
  r   以只读模式打开文件
  w   以只写模式打开文件
  a   以追加模式打开文件

  r+b 以读写模式打开
  w+b 以写读模式打开
  a+b 以追加及读模式打开	
  #+END_EXAMPLE

 文件对象操作完毕，记得使用close()方法把它关闭，这样才有始有终。

 mode决定了open()的返回值。mode决定了所返回的文件对象的特性。

 当mode为b的时候，返回的文件对象是以字节为单位操作文件的。

 当mode为t的时候，返回的文件对象是以字符为单位操作文件的，这是默认的操作。

 当mode为w时，总是清空文件；

 当mode为r时，打开的文件为只读模式；这是默认的操作。

 当mode为w时，打开的文件为只写模式，不可读。

 当mode为a时，打开的文件为追加写模式，不可读。

 打开一个文件，只能做读、写、追加模式中的一种。

 当r,w,a与+一起使用的时候，文件可读可写。r+文件指针在开头；w+清空文
 件；a+文件指针在末尾。

 w模式总是清空文件。

 获取当前文件指针的位置tell方法。

 当mode为x时，与w类似，如果文件存在时，x会抛出FileExistsError。

 凡是有r的，都不会创建文件，当文件不存在时，会抛出FileNotFoundError。

 open()方法之buffering参数解释：用来设置buffer策略，缺省值为-1。
 1. buffering=-1
	+ 二进制模式：DEFAULT_BUFFER_SIZE
	+ 文本模式：DEFAULT_BUFFER_SIZE
 2. buffering=0
	+ 二进制模式：unbuffered
	+ 文本模式：不允许
 3. buffering=1
	+ 二进制模式：unbuffered
	+ 文本模式：line buffering
 4. buffering>1
	+ 二进制模式：buffering
	+ 文本模式：DEFAULT_BUFFER_SIZE

 二进制模式与文本模式的flush区别
 1. 二进制模式：判断缓冲区剩余位置是否足够存放当前字节，如果不能，先
	flush，在把当前字节写入缓冲区；如果当前字节大于缓冲区大小，直接
	flush。
 2. 文本模式：line buffering，遇到换行就flush；非line buffering，当
	前字节加缓冲区中的字节，超出缓冲区大小，直接flush缓冲区和当前字节。
 3. flush和close可以强制刷新缓冲区

 #+BEGIN_SRC python :results output :exports both
   f = open('hello.py', 'wb', buffering=5)
   f.write(b'abc') # 检查缓冲区是否足够写入当前字节，如果不够，flush缓冲区，然后在把当前字节写入缓冲区
   # cat hello.py # 空
   f.write(b'ABC')
   # cat hello.py # abc

   f.close()

   # 设置buffering为0
   f = open('hello.py', 'wb', buffering=0)
   f.write(b'abc')
   # cat hello.py
   f.close()

   # 写入的量超过buffering
   f = open('hello.py', 'wb', buffering=5)
   f.write(b'abcdefgh')
   # cat hello.py
   f.close()

   # 查看系统默认的buffer size
   import io
   print(io.DEFAULT_BUFFER_SIZE)
 #+END_SRC

 open()方法之encoding参数解释：
** 文件对象的其他操作
 write和writelines的区别：write参数为字符串或字节；writelines参数是
 一个可迭代对象，其元素为字符串或bytes。writelines会遍历参数，然后写入。

 write返回写入的字节数或字符数，writelines返回None。

 write操作总是向后移动文件指针。

 当文件以append模式打开时，如果使用seek来调整文件指针的位置，然后，向文件写入数据，
 那么数据还是被写入文件的末尾，而不是指定的位置。

 当mode为写的时候，总是从当前文件指针处开始写，如果原位置已存在内容，将会被覆盖。

 来一个小结：
 + 文件指针按字节操作
 + tell方法返回当前文件指针位置
 + seek方法移动文件指针
 + whence 参数SEEK_SET(0) 从0开始向后移动offset个字节，SEEK_CUR（1）
   从当前位置向后移动offset个字节;SEEK_END(2) 从EOF向后移动offset个字节
 + offset是整数
 + 当mode为t时，whence为SEEK_CUR或者SEEK_END时，offset只能为0
 + 文件指针不能为负数
 + 读文件的时候从文件指针（pos）开始向后读
 + 写文件的时候从min（EOF，pos）处开始向后写
 + 以append模式打开的时候，无论文件指针在何处，都从EOF开始写

 *如何实现插入操作？*

 truncate从文件指针处开始。truncate清空操作，如果不指定位置，从当前文件指针处
 开始清空，如果指定位置，则从指定位置处开始清空。
*** 上下文管理
 *打开的文件在使用完成后* ，一定要关闭。如果忘记关闭怎么办？这时引入with语句。
 #+BEGIN_SRC python
with open('data.txt') as f:
  f.read()
 #+END_SRC

 context可以帮助我们自动关闭文件，不会开启新的作用域，无论with块中发生了什么。

 什么样的对象可以支持上下文管理。

 缓冲区：flush强制刷新缓冲区。

 文件指针：seek用于移动文件指针。whence 0从开始处移动，1从当前位置移
 动，2从文件末尾移动。offset为正数，向后移动；为负数向前移动。seek移
 动的是字节数。当文本模式打开，whence只能是0。seek不可以移动到文件头
 之前；seek可以移动到文件尾之后；当seek到文件尾之后，操作时从文件尾
 开始。seekable判断文件是否可以seek操作。

 tell总是以字节计算。

 #+BEGIN_SRC python
# 文件对象的其他属性
f.name
f.encoding
f.errors
f.newlines
 #+END_SRC

 StringIO

 ByteIO

 socket
 #+BEGIN_SRC python
   # server
   import socket
   sock = socket.socket()
   sock.bind(('127.0.0.1', 4000))
   sock.listen()
   so = sock.accept()
   f = so[0].makefile()
   f.writeable()
   f.readable()

   # client
   import socket
   sock = socket.socket()
   sock.connect(('127.0.0.1', 4000))
 #+END_SRC
*** File-like对象
  并不是实际的文件对象。
**** StringIO(文本模式)
   #+BEGIN_SRC python :results output :exports both
	 from io import StringIO

	 sio = StringIO()
	 sio.readable()
	 sio.writable()
	 sio.seekable()

	 sio.write('abcd')
	 sio.seek(0)
	 print(sio.read())
	 sio.close() # 用完记得关闭始终是个好习惯
   #+END_SRC

   #+RESULTS:
   : abcd

**** BytesIO(二进制模式)
   #+BEGIN_SRC python :results output :exports both
	 from io import BytesIO

	 bio = BytesIO()
	 bio.write(b'abcd')
	 bio.seek(0)
	 print(bio.read())
	 bio.close()
   #+END_SRC

   #+RESULTS:
   : b'abcd'

   BytesIO还有一个getvalue的方法，可以一次性读取全部内容，不管文件指针在哪里。
** 目录操作
*** 创建目录
  #+BEGIN_SRC python
os.mkdir() # 不能递归创建目录   mkdir xxxx mode=0o644
os.mkdir('test3', mode=0o644)
os.mkdirs() # 可以递归地创建目录 mkdir -p xxxx/yyyy exist_ok=False是默认的mode
  #+END_SRC
  当目录存在时，mkdir和makedirs都会抛出异常。
*** 删除目录
  #+BEGIN_SRC python
os.rmdir('/path/to/dir') # rmdir /path/to/dir，只能删除空目录
os.removedirs('/path/to/dir') # 递归地删除空目录
import shutil
shutil.rmtree('/tmp/test') # rm -rf /tmp/test 递归删除目录

shutil.rmtree('/srv/apps/ewf-sm', ignores=True)
shutil.rmtree('/srv/apps/ewf-sm', onerror=lambda fn, path, exec_info: print(path))
shutil.rmtree('/srv/apps/ewf-sm', onerror=lambda fn, path, exec_info: print(fn))
shutil.rmtree('/srv/apps/ewf-sm', onerror=lambda fn, path, exec_info: print('{} => {}'.format(path, exec_info[1])))
  #+END_SRC
*** 移动目录
  os库里没有移动目录的方法。可以使用shutil.move()方法。
  #+BEGIN_SRC python
shutil.move('/tmp/test', '/tmp/test2') # mv /tmp/test /tmp/test2
  #+END_SRC
*** 复制目录
  #+BEGIN_SRC python
shutil.copy()
shutil.copy2()
shutil.copytree()
# copy        数据与权限
# copy2       数据与stat info（权限、atime、ctime、mtime、flags）
# copyfile    数据
# copymode    权限
# copystat    stat info
# copyfileobj 对两个文件对象进行操作
# copytree    递归的复制目录，具体使用哪个copy函数，可以指定。symlinks=True
  #+END_SRC
*** 遍历目录
  #+BEGIN_SRC python
import os
os.listdir('/tmp') # ls -a
os.walk('/tmp', topdown=False) # 返回的是一个生成器
# 默认是深度优先遍历，topdown=False设置为广度优先遍历
for root, dirs, files in os.walk('/tmp', onerror=lambda e: print(e)):
  print(root)
  print(dirs)
  print(files)
  #+END_SRC

  作业：自己实现os.walk()

  #+BEGIN_SRC python
os.scandir()
  #+END_SRC
*** 路径相关操作
  在python3.4之前，使用os.path以字符串的形式操作路径。在Python3.4之
  后，是使用pathlib以面向对象的方式操作路径。

  #+BEGIN_SRC python
os.path.basename('/tmp/file') # file
os.path.dirname('/tmp/file') # /tmp
os.path.join('/', 'tmp', 'file') # /tmp/file
os.path.split('/tmp/d/file') # ('/tmp/d', 'file')
os.path.abspath()
os.path.getcwd()
  #+END_SRC

  获得脚本所在目录的绝对路径，
  #+BEGIN_SRC python
os.path.abspath(os.path.dirname(sys.argv[0]))
  #+END_SRC

  #+BEGIN_SRC python :results output :exports both
	import pathlib

	cwd = pathlib.Path('.')
	print(cwd)
	cwd.is_dir()

	cwd.iterdir() # 对当前目录进行遍历，不会进行递归的遍历
  #+END_SRC

  #+RESULTS:
  : .

  创建目录，
  #+BEGIN_SRC python :results output :exports both
	import pathlib

	cwd = pathlib.Path('./abcd')
	d.exists()
	d.mkdir(0o755)
  #+END_SRC

  删除目录时，要删除的目录是空目录。

  通用操作，
  #+BEGIN_SRC python :results output :exports both
	import pathlib

	f = pathlib.Path('./abcd')
	f.exists() # 判断路径是否存在
	f.is_file() # 当路径不存在时，is_*方法都返回False
	f.is_dir()

	f = pathlib.Path('./hello.py')
	f.is_file() # 判断是否是文件
	f.is_absolute() # 判断是否为绝对路径
	f.absolute() # 返回绝对路径
	f.absolute().as_uri() # 转换为URI的形式，如file:///path/to/file
	f.cwd() # 路径或文件所在的当前目录
	f.drive # Windows系统特有的，在Unix下为返回空字符
  #+END_SRC
** 序列化与反序列化
 序列化   对象->str/bytes
 反序列化 str/bytes->对象

 pickle
 #+BEGIN_SRC python :results output :session
import pickle
pickle.dumps(1)
pickle.dumps([1, 2, 3])
pickle.dumps({'a': 1})

class A:
  def __init__(self, a):
	  self.a = a

  def prnt(self):
	  print(self.a)

a = A(3)
pickle.dumps(a)
In [5]: pickle.dumps(a)
Out[5]: b'\x80\x03c__main__\nA\nq\x00)\x81q\x01}q\x02X\x01\x00\x00\x00aq\x03K\x03sb.'

In [6]: 
 #+END_SRC

pickle可以序列化Python大多数的对象。只能在Python程序之间传输数据。

pickle.dumps pickle.loads处理的是bytes对象。

pickle.dump pickle.load处理的是文件。

json仅仅可以序列化int float list dict bool None str
 #+BEGIN_SRC python
Python  json
int -> number
float -> number
str -> string
bool -> bool
None -> null
list -> Array
tuple -> Array
dict -> object
 #+END_SRC
* 面向对象编程
数据封装、继承和多态是面向对象的三大特点。

Python2与Python3的区别，Python3都是新式类。经典类和新式类的区别：
+ __slots__ # (在python3中，只有槽中的属性可以被访问)
+ 继承顺序，super
+ __new__
+ __getattribute__
** 面向对象基础
面向对象是一种编程范式。范式是指一组方法论。编程范式是一组如何组织
代码的方法论。

数据库的三范式。

编程范式指的是软件工程中的一种方法学。

主流的编程范式：
1. OOP	- 面向对象编程
#+BEGIN_EXAMPLE
世界观：一切皆对象
#+END_EXAMPLE
2. FP	- 函数式编程
#+BEGIN_EXAMPLE
世界观：一切皆函数。一般指无副作用的函数。
#+END_EXAMPLE
3. PP	- 过程化编程
4. IP	- 指令式编程
5. LP	- 逻辑化编程
6. AOP	- 面向方面编程 装饰器

设计模式：
1. 自顶向下
2. 自底向上

大问题切割成小问题。对世界抽象的不够。

面向对象更进一步的抽象了世界。OOP的世界观：
1. 世界是由对象组成的
2. 对象具有运动规律和内部状态
3. 对象之间可以相互作用

面向对象的特性：
1. 唯一性：对象都是唯一的，不存在两个相同的对象，除非他们是同一个对象。
2. 分类性：对象是可分类的，世界是由不同的类型组成的。

面向对象的三大特征：
1. 封装
2. 继承
3. 多态

面向对象的本质：对行为和数据的封装；有时候数据就是数据；有时候行为就是行为。
#+BEGIN_SRC python :results output :exports both
from collections import namedtuple

Pet = namedtuple('Pet', ['name', 'age'])
#+END_SRC

目的是为了组织数据。命名元组的优势：组织的更好，字段有名字。
#+BEGIN_SRC python :results output :exports both
from collections import namedtuple

Door = namedtuple('Door', ['number', 'status'])

# 实例化
door = Door(1001, 'closed')
print(door.status)
print(door.number)
#+END_SRC

#+RESULTS:
: closed
: 1001

以面向对象的方式实现Door，
#+BEGIN_SRC python :results output :exports both
class Door:
	def __init__(self, number, status):
		# . 用于访问对象的属性及方法
		self.number = number
		self.status = status

door = Door(1001, 'closed')
print(door.number)
print(door.status)
#+END_SRC

#+RESULTS:
: 1001
: closed

#+BEGIN_SRC python :results output :exports both
class B:
	def __init__(self, a, b, c, d):
		print(a)
		print(b)
		print(c)
		print(d)

b = B(1, 2, 3, 4)
#+END_SRC

#+RESULTS:
: 1
: 2
: 3
: 4

1. 创建对象使用类名 /__init__ 函数除第一个参数外的参数列表/
2. 创建对象的时候实际执行了 /__init__函数/

*** 实例化的过程
  #+BEGIN_SRC python
class Heap:
  def __init__(self): # 此函数通常叫做构造函数，在Python中更多叫做初
					  # 始化函数，在对象创建完成后会立刻执行
	  self.data = []

  def add(self, x): # 第一个参数是self，其他参数与函数定义一样
	  pass

  def pop(self):
	  pass
  #+END_SRC
  self代表这个实例。

  一个示例，
  #+BEGIN_SRC python :results output :exports both
class Door:
  def __init__(self, number, status):
	  self.number = number
	  self.status = status

  def open(self):
	  self.status = 'opened'

  def close(self):
	  self.status = 'closed'

door = Door(1, 'closed') # 看起来非常像一个函数调用。事实上，
					   # 确实发生了一些函数调用，它调用了__init__函数，
					   # 第一个参数由解释器自动传入，表示实例本身，
					   # 通常命名为self
print(door.__class__)
print(Door.__class__)
print(type.__class__)
# 所有类，都是type或者type的子类的实例
  #+END_SRC

  #+RESULTS:
  : <class '__main__.Door'>
  : <class 'type'>
  : <class 'type'>

__init__函数并不会创建对象，__init__函数初始化对象。对象创建过程为：
1. 首先创建对象
2. 对象作为self参数传递给__init__函数
3. 返回self

实例怎么来的？由类的__new__方法实现。如果要改变默认的创建实例的行
为，可以写__new__方法，但通常是不写的。
  #+BEGIN_SRC python :results output :exports both
class Door:
#    def __new__(cls): # 创建实例的，可以改变实例创建的行为，这就是元编程的体现
#        pass

  def __init__(self, number, status):
	  self.number = number
	  self.status = status

  def open(self):
	  self.status = 'opened'

  def close(self):
	  self.status = 'closed'

door = Door(1, 'closed') # 看起来非常像一个函数调用。事实上，
					   # 确实发生了一些函数调用，它调用了__init__函数，
					   # 第一个参数由解释器自动传入，表示实例本身，
					   # 通常命名为self
print(door.__class__)
print(Door.__class__)
print(type.__class__)
# 所有类，都是type或者type的子类的实例
  #+END_SRC

  #+RESULTS:
  : <class '__main__.Door'>
  : <class 'type'>
  : <class 'type'>

实例化的时候，传递的参数列表是__init__方法除了第一个参数之外的所有
参数，支持函数的所有参数变化。

当没有显式的定义__init__方法的时候，会使用默认的__init__方法，
  #+BEGIN_SRC python
def __init__(self):
  pass
  #+END_SRC

通过.操作符访问实例的属性或者调用实例的方法。当我们调用实例方法的
时候，第一个参数即实例本身，由解释器自动传入。
**** 类的作用域
   #+BEGIN_EXAMPLE
   实例变量的作用域是在实例内部。

   所有实例共享类变量。赋值会产生新的变量。

   实例可以动态增减属性。

   类变量可以通过类直接访问，而且通过类修改变量，会影响所有实例。

   方法的作用域是类级别的。
   #+END_EXAMPLE

   结合一个简单的例子说明，
  #+BEGIN_SRC python
class Door:
  type = 'A' # 类的直接下级作用域的变量，叫做类变量

  def __init__(self, number, status):
	  self.number = number # 关联到实例的变量，叫做实例变量
	  self.status = status

  def open(self):
	  self.status = 'opened'

  def close(self):
	  self.status = 'closed'

d1 = Door(1, 'closed')
d2 = Door(2, 'opened')

d2.open = lambda self: print('haha fuck it') # monkey path
d2.open()
d1.open()
  #+END_SRC

  类变量对类和实例都可见。再看一个例子：
  #+BEGIN_SRC python :results output :exports both
	class E:
		NAME = 'E'

		def __init__(self, name):
			self.name = name

	e = E('e')

	print(e.NAME) # 等价于e.__class__.NAME
	print(e.__class__.NAME)
	e.NAME = 'xxx' # 等价于e.__dict__['NAME'] = 'xxx'
	print(e.NAME)
	print(e.__class__.NAME)
  #+END_SRC

#+RESULTS:
: E
: E
: xxx
: E

  属性的查找顺序为：
  1. __dict__
  2. __class__

  *赋值即创建*
**** 类装饰器
   先来个例子热热身：
   #+BEGIN_SRC python :results output :exports both
	 def set_name(cls, name):
		 cls.NAME = name
		 return cls


	 class F:
		 pass

	 F1 = set_name(F, 'F')
	 f1 = F1()
	 print(F1.NAME)
	 print(f1.NAME)
   #+END_SRC

#+RESULTS:
: F
: F

   以装饰器的方式实现：
   #+BEGIN_SRC python :results output :exports both
	 def set_name(name):
		 def wrap(cls):
			 cls.NAME = name
			 return cls
		 return wrap


	 @set_name('G')
	 class G:
		 pass

	 print(G.NAME)

	 # 上述过程等价于下面的几行代码：
	 # class G:
	 #     pass

	 # G = set_name('G')(G)
   #+END_SRC

#+RESULTS:
: G

   上面的例子是给类动态增加属性，下面给类动态增加方法：
   #+BEGIN_SRC python :results output :exports both
	 def print_name(cls):
		 def get_name(self):
			 return cls.__name__
		 cls.__get_name__ = get_name
		 return cls


	 @print_name
	 class H:
		 pass

	 h = H()
	 print(h.__get_name__())
   #+END_SRC

#+RESULTS:
: H

   类装饰器通常用于给类增加属性。
**** 类方法/静态方法
   方法都是类级的。方法的定义都是类级的，但是有的方法使用实例调用，
   有的方法使用类来调用。什么样的方法使用类来调用呢？接下来看一个例子：
   #+BEGIN_SRC python :results output :exports both
	 class I:
		 def instance_print(self):
			 print('instance method')

		 @classmethod # 当一个方法被classmethod装饰的时候，第一个参数会变成类本身，这样的方法叫类方法
		 def class_print(cls):
			 print(id(cls))
			 print('class method')

		 @staticmethod # 当一个方法，被staticmethod装饰的时候，不会自动传递第一个参数，这样的方法叫静态方法
		 def static_print():
			 print('static method')

		 def xxx_print(): # 在类中定义的一个方法（函数）；与staticmethod的区别是，该方法不能被实例调用
			 print('this is a function')

	 i = I()
	 i.instance_print() # 实例调用实例方法时，会自动传入self参数，self为实例本身 I.instance_print(i)
	 I.class_print()
	 print(id(I))
	 i.class_print() # 类方法可以被实例调用，并且被实例使用时，传入的参数还是类
	 i.static_print()
	 I.static_print()
	 I.xxx_print()
	 # i.xxx_print()
   #+END_SRC

#+RESULTS:
: instance method
: 4302355800
: class method
: 4302355800
: 4302355800
: class method
: static method
: static method
: this is a function

  实例方法只能又实例调用。实例方法与类方法，实例方法和类方法的区别在
  于传入的第一个参数，实例方法会自动传入当前实例，类方法会自动传入当
  前类。类方法可以被实例使用，并且被实例使用时，传入的第一个参数还是
  类。
  #+BEGIN_SRC python
class A:
  def method_of_instance(self):
	  print('method of instance')

  @classmethod
  def method_of_class(cls):
	  print('method of class')

a = A()
a.method_of_instance()
a.method_of_class()

A.method_of_instance()
A.method_of_class()
  #+END_SRC

  再看一个例子，当我们用实例调用方法的时候，总是会传入一个参数，
  要么是实例本身，要么是它的类。
  #+BEGIN_SRC python
class A:
  def method_of_instance(self):
	  print('method of instance')

  @classmethod
  def method_of_class(cls):
	  print('method of class')

  @staticmethod
  def static_method(): # 这就是静态方法，静态方法不能由实例调用
					   # 通常，我们会加@staticmethod装饰器作为标示，
					   # @staticmethod装饰器不做任何事情
	  print('static method')

a = A()
a.method_of_instance()
a.method_of_class()
a.static_method()

A.method_of_instance()
A.method_of_class()
A.static_method()
A.method_of_instance(a)

# 实例调用方法的时候，始终会传入实例本身作为第一个参数；
# 类  调用方法的时候，始终不会传递本身作为第一个参数；
# @classmethod 装饰器会向方法传递一个参数，传递的是类本身；
  #+END_SRC

  方法的作用域都属于类级别，具体是实例方法，还是类方法，或者是静态方
  法，由第一个参数决定，当第一个参数是实例的时候，是实例方法；当第一
  个参数是类的时候，是类方法，当不要求第一个参数时，是静态方法。

  #+BEGIN_SRC python
class A:
  var = 'A'

  @classmethod
  def change_var(cls, val):
	  cls.var = val

a1 = A()
a2 = A()

A.change_var('B')
a1.var
a2.var

a1.change_var('C')
a1.var
a2.var
  #+END_SRC

  再来看一个例子：
  #+BEGIN_SRC python :results output :exports both
	class Car:
		country = u"中国"

		def __init__(self, length, width, height, owner=None):
			self.owner = owner
			self.length = length
			self.width = width
			self.height = height
			self.country = "china"

	if __name__ == '__main__':
		a = Car(1.2, 1.4, 1.5, u"大川")
		b = Car(2.2, 2.4, 2.5, u"淘气")
		print(a.owner, b.owner)
		print(a.country, b.country)

		b.country = u"美国"
		print(a.country, b.country)
		print(Car.country)
		print("-------------------")
		del a.country
		print(a.country)
  #+END_SRC

#+RESULTS:
: 大川 淘气
: china china
: china 美国
: 中国
: -------------------
: 中国

  所有实例需要共享一些状态、数据的时候，就可以使用类变量。当在实例中
  需要修改类变量的时候，我们就可以把修改的内容放到类方法中。

  类变量被赋值的话（赋值会产生新的引用），就会变成了实例变量。
**** 访问控制
   这里主要涉及公有变量、私有变量及公有方法、私有方法。
   #+BEGIN_SRC python :results output :exports both
	 class Door:
		 def __init__(self, number, status):
			 self.number = number
			 self.__status = status

		 def open(self):
			 self.__status = 'opening'

		 def close(self):
			 self.__status = 'closed'

		 def status(self):
			 return self.__status

		 def __set_number(self, number):
			 self.number = number

	 door = Door(1001, 'closed')
	 # door.__status # 报错
	 door.__status = 'fuck it'
	 print(door.__status)
	 door.status()
	 door.open()
	 door.status()
	 # door.__set_number(5001)
	 print(door._Door__status)
   #+END_SRC

#+RESULTS:
: fuck it
: opening

   所有双下划线，非双下划线结尾的成员，都是私有成员。对于上述
   的__status私有变量，如何进行访问呢？在Python中，可以通过
   #+BEGIN_SRC python
   _类名+带双下划线的属性
   #+END_SRC
   Python的私有成员是通过改名实现的。严格地说，Python里没有真正的私
   有成员。除非真的有必要，并且清楚知道会有什么后果，否则不要用这个
   黑魔法。90%的程序员有生之年用不到。

   接下来再看看以单下划线开始的变量，
   #+BEGIN_SRC python :results output :exports both
	 class J:
		 def __init__(self):
			 self._a = 3

	 j = J()
	 print(j._a)
	 j._a = 4
	 print(j._a)
	 print(j.__dict__)
   #+END_SRC

#+RESULTS:
: 3
: 4
: {'_a': 4}

   单下划线开始的变量是一种惯用法，标记此成员为私有，但是解释器不做
   任何处理。

   接下来介绍property装饰器，
   #+BEGIN_SRC python :results output :exports both
	 class Door:
		 def __init__(self, number, status):
			 self.number = number
			 self.__status = status

		 def open(self):
			 self.__status = 'opening'

		 def close(self):
			 self.__status = 'closed'

		 @property # property装饰器会把一个仅有self参数的函数，变成一个属性，属性的值为方法的返回值
		 def status(self):
			 return self.__status

		 def __set_number(self, number):
			 self.number = number

	 door = Door(1001, 'closed')
	 print(door.status)
	 # door.status() # 会报错
   #+END_SRC
*** 封装
  一个例子，
  #+BEGIN_SRC python
Heap = namedtuple('Heap', ['add', 'pop'])

def heap_factory():
  data = []

  def add(x):
	  pass

  def pop():
	  pass

  return Heap(add, pop)

heap = heap_factory()
# 对外界来说，data是不可见的，外界无法访问data
  #+END_SRC

  在Python中如何进行封装的？来看一个小例子，
  #+BEGIN_SRC python :results output :exports both
class A:
  def __init__(self, x, y, z):
	  self.x = x
	  self.y = y
	  self.z = z

a = A(1, 2, 3)
print(a.x)
print(a.y)
print(a.z)
a.x = 2
print(a.x)
  #+END_SRC

#+RESULTS:
: 1
: 2
: 3
: 2

  下面是封装的例子，
  #+BEGIN_SRC python
class B:
  def __init__(self, x, y, z):
	  self.x = x
	  self.__y = y
	  self._z = z

b = B(1, 2, 3)
b.x
b.__y
b._z
  #+END_SRC

  在Python中，以双下划线开始，并且不以双下划线结尾的变量，是私有变量，
  外界无法直接访问。通常，我们不定义以双下线开始，双下划线结尾的变量
  和方法，因为这在Python中有特殊含义。

  接下来看看私有方法，方法也是一样的规则，以双下划线开头，非双下划线
  结尾的方法是私有方法。
  #+BEGIN_SRC python
class D:
  def __private_method(self):
	  print('private method')

d = D()
d.__private_method()

# 通过dir(d)时，也看不到__private_method()方法。
  #+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Traceback (most recent call last):
File "<stdin>", line 6, in <module>
AttributeError: 'D' object has no attribute '__private_method'
#+END_EXAMPLE

  一个稍微综合的例子，
  #+BEGIN_SRC python :results output :exports both
class F:
  __private_class_var = u'私有类变量'

  def __init__(self):
	  self.__private_instance_var = u'私有实例变量'

  @classmethod
  def public_class_method(cls):
	  print(cls.__private_class_var)

  def public_instance_method(self):
	  print(self.__private_class_var)
	  print(self.__private_instance_var)

f = F()
f.public_class_method()
f.public_instance_method()
  #+END_SRC

#+RESULTS:
: 私有类变量
: 私有类变量
: 私有实例变量

  私有属性在类的内部均可访问，无论是类方法还是实例方法。接下来再看一
  个稍微变态的例子，
  #+BEGIN_SRC python :results output :exports both
class G:
  __private_class_var = 'private class var'

  def public_instance_method(self):
	  print(G.__private_class_var)

g = G()
g.public_instance_method()
G.__private_class_var # 会提示没有这个对象
  #+END_SRC

#+RESULTS:

  再来一个例子，
  #+BEGIN_SRC python
class H:
  __private_class_var = 'private class var'

  @staticmethod
  def public_static_method():
	  print(H.__private_class_var)

h = H()
h.public_static_method()
H.public_static_method()
  #+END_SRC

  前面说过，类的私有属性是不能直接被访问的，这是真的吗？接着看F这个例子，
  #+BEGIN_SRC python
class F:
  __private_class_var = 'private class var'

  def __init__(self):
	  self.__private_instance_var = 'private instance var'

  @classmethod
  def public_class_method(cls):
	  print(cls.__private_class_var)

  def public_instance_method(self):
	  print(self.__private_class_var)
	  print(self.__private_instance_var)

f = F()
f.public_class_method()
f.public_instance_method()

# 使用__dict__查看实例f的属性
f.__dict__
f._F__private_instance_var
  #+END_SRC

  事实上，Python的私有属性并不是真正私有，而是一个变量重命名而已。看
  一个例子说明此问题：
  #+BEGIN_SRC python
class J:
  def __init__(self):
	  self.__a = 1
	  self.__b = 2

  def __private_method(self):
	  print('private method')

j = J()
j._J__a
j._J__private_method()
  #+END_SRC

  一个综合点的例子，
  #+BEGIN_SRC python
	class Door:
		def __init__(self, number, status):
			self.number = number
			self.__status = status

		def open(self):
			self.__status = 'opened'

		def close(self):
			self.__status = 'closed'

		def get_status(self):
			return self.__status

		@property
		def status(self):
			"""
			使用property装饰器描述符对status方法进行装饰，
			可以让我们访问status方法像访问类的属性一样。
			"""
			return self.__status

	door = Door(1, 'number')
	door.open()
	door.status = 'opened'
	door.get_status()
	door.status # 属性
  #+END_SRC

  还想对status进行赋值，但赋值只能是opened或closed，该怎么破？
  #+BEGIN_SRC python
class Door:
  def __init__(self, number, status):
	  self.number = number
	  self.__status = status

  def open(self):
	  self.__status = 'opened'

  def close(self):
	  self.__status = 'closed'

  @property # @proverty装饰器，可以把方法装饰成了一个同名属性
  def status(self):
	  return self.__status

  @status.setter # @xxxx.setter xxxx代表被@property装饰的属性吗，当对此属性赋值时，会调用此方法
  def status(self, value):
	  if value in ('closed', 'opened'):
		  self.__status = value
	  else:
		  raise ValueError(value)

  @status.deleter # 当删除此属性时，会调用此方法
  def status(self):
	  raise NotImplementedError('You can not delete status of door')

door = Door(1, 'number')
door.open()
door.status # 属性
door.status = 'xxxx'
door.get_status()
door.status
door.status = 'closed'

del door.status
  #+END_SRC
*** 继承
  啥也不说，先来一个例子，
  #+BEGIN_SRC python
class Base:
  def __init__(self):
	  self.x = 0

class A(Base):
  pass

a = A()
a.x
  #+END_SRC

  在Python3中，如果没有显式的指定继承哪个类，默认是继承自object类。

  子类获得父类一些（非全部）方法和属性。看一个例子，
  #+BEGIN_SRC python
class Base:
  def __init__(self):
	  self.x = 1
	  self._y = 2
	  self.__z = 3

class B(Base):
  def print_x(self):
	  print(self.x)

  def print_y(self):
	  print(self._y)

  def print_z(self):
	  print(self.__z)

b = B()
b.print_x()
b.print_y()
b.print_z() # 私有属性，无法继承

class C(Base):
  def print_z(self):
	  print(self._Base__z)

c = C()
c.print_z()
  #+END_SRC

  无论是类变量还是实例变量都可以继承；类方法、实例方法和静态方法都可
  以继承，但私有的除外。

  方法重写: 子类覆盖父类的方法。
  #+BEGIN_SRC python
class Base:
  def my_print(self):
	  print('I am Base class')

class F(Base):
  def my_print(self):
	  print('I am F class')

f = F()
f.my_print()
  #+END_SRC

  如果还要父类的方法呢？可以使用super()方法。super()方法返回super对象，
  可以使用super对象调用父类的方法。
  #+BEGIN_SRC python
class Base:
  def my_print(self):
	  print('I am Base')

class G(Base):
  def my_print(self):
	  print('I am G')
	  super().my_print() # super()等价于super(__class__, self) -> Base
						 # python2中的写法为super(G, self)

g = G()
g.my_print()
  #+END_SRC

  能否继承祖先类的属性呢？
  #+BEGIN_SRC python
class TopBase:
  def my_print(self):
	  print('I am Top')

class Base(TopBase):
  def my_print(self):
	  print('I am Base')

class H(Base):
  def my_print(self):
	  super(Base, self).my_print() # super(Base, self) -> TopBase, 返回当前类的父类

h = H()
h.my_print()  # 看来没有问题，
  #+END_SRC

  通过上面的例子的演示，super对象不但可以使用父类的属性，还能使用祖
  先的属性。super(type, obj)返回super对象，指代type的父类。

  super对象持有类级别的成员。举个例子看看，
  #+BEGIN_SRC python
class Base:
  @classmethod
  def my_print(cls):
	  print('Base')

class D(Base):
  @classmethod
  def my_print(cls):
	  print('D')
	  super().my_print() # 这里的super()，相当于super(D, cls)

d = D()
d.my_print()
  #+END_SRC

  当父类定义了带参数的初始化方法时，子类要显式的定义初始化方法，
  并且在初始化方法里初始化父类。
*** 多继承与MRO
  MRO：方法查找顺序。MRO的两个原则：
  1. 本地优先：自己定义或重写的方法优先；否则按照继承列表，从左向右查找。
  2. 单调性：所有子类，也要满足查找顺序。

  Python通过C3算法来确定是否满足MRO的两个原则。

  在Python3中的写法是等价的，
  #+BEGIN_SRC python
class A:
  pass

class A(object):
  pass
  #+END_SRC

  在Python2.3之前，没有一个最上层的基类；从2.4版本开始，Python引入了
  object这个最上层的基类，即所有类都继承自object，但是为了兼容，必须
  要显式指定。在Python2中，如果是第一种写法，无法使用super方法。

  针对Python3，因为不用兼容旧风格，所以两种写法是等效的，通常使用第
  一种写法。

  Python支持多继承。
  #+BEGIN_SRC python
class A:
  def my_print(self):
	  print('A')

class B:
  def my_print(self):
	  print('B')

class C(A, B):
  pass

c = C()
c.my_print()

class D(B, A):
  pass

d = D()
d.my_print()

class E(A):
  def my_print(self):
	  print('E')

class F(E, B):
  pass

f = F()
f.my_print()

class G(E, A):
  pass

G().my_print()

class H(A, E):
  pass # 此类有问题，MRO的问题

A.__mro__
E.__mro__
G.__mro__
  #+END_SRC

  这里存在MRO的问题，MRO使用C3算法计算。这里假设有一个如下的类，
  #+BEGIN_SRC python
class B: -> mro(B) => [B, O]
B.__mro__
(__main__.B, object)
  #+END_SRC

  C3算法，
  #+BEGIN_SRC python
class B(O) -> mro(B) = [B, O]
class B(A1, A2, ..., An) -> mro(B) = [B] + merge(mro(A1), mro(A2), ..., mro(An), [A1, A2, ..., An, O])
  #+END_SRC

  以上的merge步骤是如何工作的？C3算法的merge步骤（2016年10月18日笔记），
  1. 顺序遍历列表
  2. 取出首元素，满足以下规则，则加入到目标列表，否则遍历下一个序列
	 1. 它在其他序列里也是首元素
	 2. 它在其他序列里不存在
  3. 重复执行，直到循环完毕所有元素，或者无法继续，抛出异常。

  C3算法的merge的步骤（2017年2月19日笔记）：
  1. x

  一个推演，
  #+BEGIN_SRC python
class C(A, B) ==>
mro(C) => [C] + merge(mro(A), mro(B), [A, B])
	 => [C] + merge([A, O], [B, O], [A, B])
	 => [C, A] + merge([O], [B, O], [B])
	 => [C, A, B] + merge([O], [O])
	 => [C, A, B, O]
C.__mro__
  #+END_SRC

  另外一个推演，
  #+BEGIN_SRC python
class E(A):
class H(A, E):
mro(H) => [H] + merge(mro(A), mro(E), [A, E])
	 => [H] + merge([A, O], [E, A, O], [A, E])
	 => [H] + # A在列表中，但[E, A, O]中的A不是首元素，因此抛出异常
	 raise TypeError
  #+END_SRC

  当一个类定义的时候，解释器会执行C3算法来确定MRO，如果C3算法抛出异
  常，此类不能被定义。

  应该尽量避免使用多继承。有限的场景下，多继承能让编码变得非常灵活。

  多继承是一剂毒药，但是有时嗑药也很兴奋。接下来介绍多继承的的应用场景。
*** MixIn
MinIn是一种组合。在Python中，可以通过多继承来实现MinIn。
  #+BEGIN_SRC python
import tornado.web

class MainHandler(tornado.web.RequestHandler):
  def get(self):
	  self.write('hello world')

import tornado.httpserver
import tornado.ioloop

app = tornado.web.Application([
  ('/', MainHandler)
])

server = tornado.httpserver.HTTPServer(app)
app.listen(3000, address='0.0.0.0')

tornado.ioloop.IOLoop().start()
  #+END_SRC

MixIn不能独立使用。MinIn需要在非MinIn类的前面。除了MinIn之外，始终
不要使用多继承。MinIn不是继承，是组合的一种体现。组合优于继承。其
初始化方法通常无参。

MinIn：
1. mixin通过多重继承实现
2. mixin是组合的一种方式
3. mixin类通常需要满足：
 1. 不能单独生成实例
 2. 不能继承非mixin的类

Mixin类的限制：
1. MixIn类不应该有初始化方法
2. MixIn类通常不能独立工作
3. MixIn类的祖先也应该是MixIn类

通常情况下，MixIn类总是在继承列表的第一位。
**** 20170219
   #+BEGIN_EXAMPLE
	  Document
Word                Excel
PrintableWord       PrintableExcel
   #+END_EXAMPLE
** 类的创建与销毁
 #+BEGIN_SRC python :results output :exports both
   class A:
	   def
 #+END_SRC
** 异常处理
 异常就是不正常，按照设计，程序会走完一个路径，但是这个路径会存在各
 种意外，每个意外都称之为异常。

 异常是可以被处理；错误不可处理。

 常见的错误，语法错误、缩进错误、解释器内部错误。
*** try-expect语句
  try-except语法，
  #+BEGIN_SRC python
try:
  # 可能抛出异常的语句。会一直执行，直到抛出异常。
except:
  # 异常处理语句，当try块任意语句抛出异常时执行。
  #+END_SRC

  一个小例子，
  #+BEGIN_SRC python
try:
  open('/tmp/haha')
except:
  print('open /tmp/haha error')
  #+END_SRC

  另外一个小例子，
  #+BEGIN_SRC python
try:
  print(1 + 1)         # 正常执行
  print('------')      # 正常执行
  print(1 / 0)         # 抛出异常
  print(u'不会被执行') # 不会被执行
except:
  print('except')
  #+END_SRC

  再看一个稍微复杂一点的例子，
  #+BEGIN_SRC python
try:
  open('/root/test.txt')
except Exception as e:
  print('open error /root/test.txt {}'.format(e))
  #+END_SRC

  再来看一个例子，
  #+BEGIN_SRC python
try:
  open('/root/test.txt')
except TypeError as e:
  print('open error /root/test.txt {}'.format(e))
  #+END_SRC

  通过上的例子，我们看到异常处理这里并没有捕获到异常。那么我们针对不
  同的异常做不同的处理，对上面的例子进行稍微修改，
  #+BEGIN_SRC python
# 以普通用户执行如下代码
try:
  open('/root/test.txt')
except TypeError:
  print('type error')
except PermissionError:
  print('Permission denied')
  #+END_SRC

  except可以做模式匹配，匹配特定的异常类型。
*** 什么是异常类
  BaseException的所有子类都是异常类。
  #+BEGIN_SRC python :results output :exports both
print(Exception.__mro__)
print(TypeError.__mro__)
  #+END_SRC

#+RESULTS:
: (<class 'Exception'>, <class 'BaseException'>, <class 'object'>)
: (<class 'TypeError'>, <class 'Exception'>, <class 'BaseException'>, <class 'object'>)

  except后面可以跟一个异常类，这时候，它仅仅捕获此类异常。
  #+BEGIN_SRC python :results output :exports both
try:
  raise TypeError() # 明确指定抛出TypeError异常
except TypeError:     # 明确指出捕获TypeError异常
  print('type error')
  #+END_SRC

#+RESULTS:
: type error

  #+BEGIN_SRC python :results output :exports both
try:
  raise Exception() # 明确指定抛出异常
except TypeError:     # 明确指出捕获TypeError异常，但捕获不到
  print('type error')
  #+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:  File "<stdin>", line 2, in <module>
: Exception

  由于except的模式匹配，可以针对不同的异常做不同的处理。

*** expect语句优先级
  一个try语句可以带多个except语句。异常有优先级的，来看上面的代码，并做稍微修改，
  #+BEGIN_SRC python
# 以普通用户执行
try:
  open('/root/test.txt')
except Exception:
  print('error')
except PermissionError:
  print('Permission Denied')
# 输出的结果为
error
  #+END_SRC

  当有多个except时，从上往下，匹配到第一条就停止匹配。通常会把具体的
  异常放到上面，一般性的异常放到下面。通常来说，子类更具体，父类更一
  般。还以上面的例子来说，调整一下代码的顺序，
  #+BEGIN_SRC python
try:
  open('/root/test.txt')
except PermissionError:
  print('Permission Denied')
except Exception:
  print('error')
  #+END_SRC

  在抛出异常的时候，可以给异常代码传递一些信息：
  #+BEGIN_SRC python :results output :exports both
	class CustomException(Exception):
		def __init__(self, code, message):
			self.code = code
			self.message = message
	try:
		raise CustomException(500, 'internal error')
	except CustomException as e:
		print('<{}>{}'.format(e.code, e.message))
  #+END_SRC

#+RESULTS:
: <500>internal error
*** 异常的层次
  来看一个异常的优先级问题，
  #+BEGIN_SRC python
+ BaseException
+ Exception
+ KeyboardInterrupt  # 代表是键盘中断事件，表示按下Ctrl+C组合键
+ SystemExit         # 代表的是解释器退出
+ GeneratorExit      # 代表生成器退出，当生成器退出时，会抛出此异常
  #+END_SRC

  事实上，Python标准库里，只有这四个异常直接继承自BaseException。通
  常来说，自定义异常不会直接继承BaseException。

  事实上，标准库里其他异常都直接或者间接继承自Exception，所以自定义
  异常也应该直接或者间接的继承Exception。

  #+BEGIN_SRC python :results output :exports both

  #+END_SRC
*** finally语句
  先来一段代码看看，
  #+BEGIN_SRC python
try:
  f = open('/root/read_only.txt')
  f.write('hehe\n') # 在这里抛出异常
  f.close() # 这个语句不能执行
except:
  print('open error')
  #+END_SRC
  以上这段代码执行完毕后，/root/read_only.txt文件不能被正常关闭。对
  上述代码进行稍微修改，使其可以关闭代码，这里使用finally语句，
  #+BEGIN_SRC python
f = None

try:
  f = open('/root/read_only.txt')
  f.write('hehe\n') # 在这里抛出异常
except:
  print('open error')
finally:
  print('close file')
  if f is not None:
	  f.close()
# 执行结果为
open error
close file
  #+END_SRC

  finally语句总是会执行，无论有没有抛出异常，所以清理工作，通常会放
  到finally语句块里执行。

  在Python中，try语句并不会开辟新的作用域。

  在看一个例子，主要是验证finally的执行时机：
  #+BEGIN_SRC python :results output :exports both
def fn():
  try:
	  print('try')
	  return # 遇到return，应该返回的，但finally语句块还是执行了。
  finally:
	  print('finally')

fn()
  #+END_SRC

#+RESULTS:
: try
: finally

  继续修改上面的例子，
  #+BEGIN_SRC python :results output :exports both
def fn():
  x = 2
  def inner(x):
	  print('inner')
	  return x + 1
  try:
	  print('try')
	  return x
  finally:
	  x = inner(3)

fn()
  #+END_SRC

#+RESULTS:
: try
: inner

  对上面的例子再做些修改，
  #+BEGIN_SRC python
def fn():
  x = [2]
  def inner(x):
	  print('inner')
	  return x + 1
  try:
	  print('try')
	  return x
  finally:
	  x[0] = inner(3)

fn()
try
inner
[4]
  #+END_SRC

  finally在return语句之后，函数返回之前执行。通常来说，不在finally里
  执行return。为了看清这个过程，可以做如下修改代码，
  #+BEGIN_SRC python
import time
def fn():
  def inner():
	  print('inner')
	  return 3
  try:
	  print('try')
	  return inner()
  finally:
	  time.sleep(3)
	  print('finally')

fn()
try
inner
# sleep(3)
finally
3
  #+END_SRC

  对于上面的例子，如果在finally语句块中执行return语句呢？inner()函数
  还会返回3吗？进行验证，
  #+BEGIN_SRC python
import time
def fn():
  def inner():
	  print('inner')
	  return 3
  try:
	  print('try')
	  return inner()
  finally:
	  print('finally')
	  return 5

fn()
try
inner
finally
5
  #+END_SRC

  由此，可以看出，finally总是会被执行。再看一例，
  #+BEGIN_SRC python
def fn():
  try:
	  1 / 0   # 抛出异常
	  yield 3 # 不会被执行
  except:
	  yield 4
  finally:
	  yield 5
  yield 6

for x in fn():
  print(x)

4
5
6
  #+END_SRC
*** 自定义异常与主动抛出异常
  前面我们所看到的是我们使用Python內建的异常处理，接下来我们看一下如
  何使用自定义的异常处理。如，
  #+BEGIN_SRC python
class MyException(Exception): # 继承自Exception或其子类
  pass
  #+END_SRC

  except带有一个模式匹配的概念，它会匹配所抛出的异常，是否是此类型。

  自定义异常需要我们自己来抛出。
  #+BEGIN_SRC python
raise Exception()
  #+END_SRC

  可以使用raise抛出异常，raise后面只能跟一个异常的实例。
  #+BEGIN_SRC python
class A:
  pass

raise A()
TypeError: exceptions must derive from BaseException
  #+END_SRC

  看一个raise的例子，
  #+BEGIN_SRC python
class UserException(Exception):
  pass  # 一般来说，只需要继承Exception类，执行pass就行了。

class SystemException(Exception):
  pass  # 一般来说，只需要继承Exception类，执行pass就行了。

# 或者可以这样写，使用type
# SystemException = type('SystemException', (Exception, object), {})

def div(x, y):
  if y == 0:
	  raise UserException('y must not be zero')
  return x / y

div(3, 0)
UserException: y must not be zero

# div()函数的另一种写法，这种写法更面向对象一些
def div(x, y):
  try:
	  return x / y
  except ZeroDivisionError:
	  raise UserException('y must not be zero')

# 接下来调用div()函数
try:
  div(3, 0)
except UserException as e:
  print(e)
except SystemException as e:
  pass
  #+END_SRC

  对于自定义异常，我们一般只需写pass语句就够了，如果要定制错误代码可以这样写，
  #+BEGIN_SRC python
class MyException(Exception):
  def __init__(self, code, message):
	  self.code = code
	  self.message = message
	  super().__init__(message)

  def __str__(self):
	  return '[{}] {}'.format(self.code, self.message)
  #+END_SRC

  异常的传递性：当抛出异常的时候，如果没有捕获异常，会继续传递到上层
  作用域，直到最顶层，如果最顶层还是没有处理，会中断当前线程。

  什么时候需要异常处理？

  当我们不处理异常的时候，它会向上抛出；异常的传递，异常总是向上层传
  递；实际的编码过程中，我们应该在哪一层处理异常呢？
  + 在endpoint处，处理异常；
  + endpoint通常指的是一个边界；
  + 有替代方案时，立即处理异常，使用替代方案；
  + 异常可以忽略；
  + 异常需要延后处理，并暂存异常，以便延后处理；

  Web的边界在哪里？视图函数。
  多线程的边界在哪里？target函数。
  RPC的边界在哪里？service方法。
** 模块化编程
*** 导入模块
  部分导入，导入的命名空间也是部分的。部分导入可以导入模块的任意成员。

  #+BEGIN_SRC python
from os import stat_result
from posix import stat_result

# 重命名
from os import stat_result as os_stat_result
from posix import stat_result as posix_stat_result
  #+END_SRC

  重命名用于解决名字冲突。
*** 自定义模块
  在Python中，一个py文件就是一个模块，文件名就是模块名。因为文件名是
  模块名，所有要求文件名必须符合Python标识符规范，否则无法导入。
  #+BEGIN_SRC sh
mkdir ~/module
cd module
touch x.py app.py
  #+END_SRC

  编写x.py文件，
  #+BEGIN_SRC python
name = 'x'

print('this is module x')
  #+END_SRC

  编写app.py文件，
  #+BEGIN_SRC python
import x

print(x.name)
this is module x # 导入模块，相当于执行模块
x
  #+END_SRC

  模块的__name__就是文件名，除非直接执行这个文件，此时它的__name__属
  性为__main__。
  #+BEGIN_SRC python
# 只有当直接执行模块时，才会被执行
if __name__ == '__main__':
  print('haha')
  #+END_SRC

  #+BEGIN_SRC python :results output :exports both
LavenLius-MacPro:my liuchuan$ cat import01.py 
import custom_module

print('hehe')
LavenLius-MacPro:my liuchuan$ cat custom_module.py
print(__name__)

if __name__ == '__main__':
  print('this is main module')
LavenLius-MacPro:my liuchuan$ python import01.py 
custom_module
hehe
LavenLius-MacPro:my liuchuan$ python custom_module.py
__main__
this is main module
  #+END_SRC

  sys.path就是我们查找模块的路径，如果在其中一个路径下找到，就会停止。
  如果不做修改，通常的一个顺序，当前目录->标准库->第三方库。
  #+BEGIN_SRC python :results output :exports both
import sys

for line in sys.path:
  print(line)
  #+END_SRC

#+RESULTS:
: 
: /Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip
: /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5
: /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/plat-darwin
: /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/lib-dynload
: /Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages

  一旦一个模块导入了一次，就被cache住了，不会重复导入；这样会避免循环导入。

  “import *”的写法，
  #+BEGIN_SRC python
# x.py
X = 'x'
Y = 'y'

def fn():
  print('fn')


__all__ = ['X', ]

# app.py
from x import *

print(X)
print(Y)
  #+END_SRC

  当具有__all__属性时，from xxx import *，只会导入__all__所标记的内
  容。尽量避免使用“import *”。

  目录作为模块：
  1. 一个目录下有__init__.py的时候，这个目录是一个模块（包），模块的
	 内容，写在__init__；
	 + 这个目录下的其他文件，是这个模块的子模块；
	 + 导入子模块的时候，会先导入父模块；
	 + 导入父模块，不会自动导入子模块；
	 + 子模块可以使用from parent import child这样的形式导入，也可以
	   使用import parent.child；
	 + import parent.child这种导入方式，child必须是子模块；
	 + 同一模块下的子模块，可以使用相对导入，也可以使用绝对导入；

  目录也可以作为模块， 模块的代码写到这个目录的__init__.py文件。当__init__.py文件不存在时，
  此模块没有__file__属性。

  猴子补丁，Python提供替换模块成员的方式。

  当一个模块定义了__all__属性的时候，使用星号部分引用，只会导
  入__all__指定的成员，如果没有定义__all__属性，那么会导入非下划线开
  始的成员。
*** 管理第三方模块
  使用pip管理第三方库，如果国外的pip源下载速度比较慢，可以换成国内的，
  #+BEGIN_SRC sh
cat ~/.pip/pip/conf
[global]
index-url = http://mirrors.aliyun.com/pypi/simple/
trusted-host = mirrors.aliyun.com
  #+END_SRC

  使用pip升级一个已安装的软件包，
  #+BEGIN_SRC sh
pip install --upgrade <package_name>
  #+END_SRC

  可以把要安装的包写到一个文件里，然后使用pip的-r选项来引用，
  #+BEGIN_SRC sh
cat requirements.txt
pip
# 执行
pip install -r requirements.txt
  #+END_SRC

  列出以安装的包及版本号，
  #+BEGIN_SRC sh
pip freeze
  #+END_SRC
  这样的话，当我们部署项目时，把我们需要的包及依赖的版本保存下来，然
  后可以在新的环境进行快速部署。

  开发环境使用虚拟环境进行开发。

  semver规范，如1.0.1
*** 打包
  在包（目录）的外层，写setup.py文件，
  #+BEGIN_SRC python
from distutils.core import setup # python3的写法，setuptools已经是标准库了
# from setuptools import setup # python2的写法，需要安装setuptools包

package = 'lavenliu'
version = '1.0.0'

setup(name=package,
	version=version,
	description="a test package",
	author='lavenliu',
	author_email='me@lavenliu.cn',
	url='http://lavenliu.cn',
	packages=['lavenliu', 'lavenliu.haha'])
  #+END_SRC

  然后在命令行执行，
  #+BEGIN_SRC sh
python setup.py --hlep
python setup.py build
ls build/lib/lavenliu
  #+END_SRC
*** 通常的项目组织方式
*** 自定义模块插件开发
  支持插件化的程序。

  #+BEGIN_SRC python
# mkdir monitor
# cd monitor
# mkdir monitor
# touch __init__.py
# cat __init__.py
from importlib import import_module
import threading


class Metric:
  def __init__(self, key, valude):
	  self.key = key
	  self.value = value


class Monitor:
  def __init__(self, collectors, backends):
	  self.collectors = []
	  self.backends = []

	  for collector in collectors:
		  self.load_collector(collector)

	  for backend in backends:
		  self.load_backend(backend)        

  def start(self):
	  while True:
		  for collector in self.collectors:
			  metrics = collector.run()
			  for backend in self.backends:
				  backend.send(metrics)
			  threading.Event().wait(3)

  def shutdown(self):
	  pass

  def load_collector(self, plugin): # monitor.plugin.snmp_collector.SNMPCollector
	  pkg, cls = plugin.rsplit('.', 1)
	  mod = import_module(pkg)
	  instance = getattr(mod, cls)()
	  self.collectors.append(instance)


  # monitor.plugin.logger_backend.LoggerBackend
  def load_backend(self, plugin):
	  pkg, cls = plugin.rsplit('.', 1)
	  mod = import_module(pkg)
	  # 等价于
	  # import monitor.plugin.logger_backend as mod
	  instance = getattr(mod, cls)()
	  self.backends.append(instance)


# emacs collector.py
import types
from . import Metric

class BaseCollector:
  def run(self): # list<Metric>
	  raise NotImplemented

# emacs backend.py
class BaseBackend:
  def send(self, metrics):
	  raise NotImplemented

# 在monitor包中新建plugin的包
# mkdir plugin
# touch plugin/__init__.py
# touch plugin/snmp_collector.py
from monitor.collector import BaseCollector
from monitor import Metric


class SNMPCollector(BaseCollector):
  def run(self):
	  return [Metric('test', 3)]


# 在plugin目录下创建logger_backend.py
from monitor.backend import BaseBackend


class LoggerBackend(BaseBackend):
  def send(self, metrics):
	  for metric in metrics:
		  print('{} => {}'.format(metric.key, metric.value))


# 接下来写application入口文件，
# cd .. # 退出monitor模块（目录），回到其父目录
# application.py文件与monitor模块在同级目录下
# emacs application.py
from monitor import Monitor

if __name__ == '__main__':
  monitor = Monitor(['monitor.plugin.snmp_collector.SNMPCollector'],
					['monitor.plugin.logger_backend.LoggerBackend'])
  monitor.start()
  #+END_SRC
** 类和实例
 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是
 抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对
 象”，每个对象都拥有相同的方法，但各自的数据可能不同。
** 面向对象高级
*** 使用__slots__
*** 使用@property
*** 多重继承
*** 定制类
*** 元编程
  动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，
  而是运行时动态创建的。我们在hello.py模块里定义一个Hello的类。当
  Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结
  果就是动态创建出一个Hello的class对象。

  我们说class的定义是运行时动态创建的，而创建class的方法就是使用
  type()函数。

  type()函数既可以返回一个对象的类型，又可以创建出新的类型。

  元编程：用代码创建了一种新的类型，也就是代码具有写代码的能力。通过
  元编程，我们可以控制类的创建的过程。类创建的过程：
  + 成员
  + 继承列表
**** type函数
   我们可以通过type()函数创建出Hello类，而无需通过class
   Hello(object)的定义。一个示例代码：
   #+BEGIN_SRC python :results output :exports both
	 def fn(self, name='world'):
		 print('Hello, %s.' % name)

	 if __name__ == '__main__':
		 # 创建Hello class
		 Hello = type('Hello', (object,), dict(hello=fn))
		 # 实例化
		 hello = Hello()
		 # 调用实例hello的hello方法
		 hello.hello()
		 print(type(Hello))
		 print(type(hello))
   #+END_SRC

#+RESULTS:
: Hello, world.
: <class 'type'>
: <class '__main__.Hello'>

要创建一个class对象，type()函数一次传入3个参数：
1. class的名称；
2. 继承的父类，注意Python支持多继承，如果只有一个父类，注意元组单元素的写法；
3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。

元类，继承自type的类，都叫元类。元类可以重写__new__方法，改变type的行为。
 #+BEGIN_SRC python
type(name, bases, attrs)
name: 类名字符串
bases: 继承的父类，是一个元组（如果只有一个父类，注意单元素元组的书写方法）
attrs: 属性字典（类绑定了哪些方法）

A = type('A', (object, ), {'b': 1})
a = A()
print(A, a.b)
 #+END_SRC

上述的代码运行结果为：
 #+BEGIN_SRC python :results output :exports both
   A = type('A', (object, ), {'b': 1})
   a = A()
   print(A, a.b)
 #+END_SRC

 #+RESULTS:
 : <class '__main__.A'> 1

一个简单的例子：
 #+BEGIN_SRC python :results output :exports both
   def howdy(self, you):
	   print('Howdy, ' + you)


   MyList = type('MyList', (list, ), dict(x=42, howdy=howdy))

   ml = MyList()
   ml.append("James")
   print(ml)
   print(ml.x)
   ml.howdy("John")
 #+END_SRC

 #+RESULTS:
 : ['James']
 : 42
 : Howdy, John

通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。
**** metaclass
除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。metalass直译为元类。简单的解释就是：先定义metaclass，就可以创建类，最后创建实例。所以，metaclass允许我们创建类或者修改类。换句话说，我们可以把类看成是metaclass创建出来的“实例”。

来个例子，定义一个metaclass将我们自己定义的MyList增加一个add方法。定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：
   #+BEGIN_SRC python :results output :exports both
	 # metaclass是类的模板，所以必须从type类型派生
	 class ListMetaclass(type):
		 def __new__(cls, name, bases, attrs):
			 attrs['add'] = lambda self, value: self.append(value)
			 return type.__new__(cls, name, bases, attrs)
   #+END_SRC

有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：
   #+BEGIN_SRC python :results output :exports both
	 class ListMetaclass(type):
		 def __new__(cls, name, bases, attrs):
			 attrs['add'] = lambda self, value: self.append(value)
			 return type.__new__(cls, name, bases, attrs)


	 class MyList(list, metaclass=ListMetaclass):
		 pass

	 # 测试
	 L = MyList()
	 L.add(1)
	 print(L)
   #+END_SRC

#+RESULTS:
: [1]

当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.new()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。

new()方法接收到的参数依次是：
1. 当前准备创建的类对象；
2. 类的名字；
3. 类继承的父类集合；
4. 类的方法集合。

动态修改有什么意义？直接在MyList定义中写add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。

但是，总会遇到需要修改metaclass修改类定义的。ORM就是一个典型的例子。让我们来尝试编写一个ORM框架。
   #+BEGIN_SRC python :results output :exports both
	 class User(Model):
		 # 定义类的属性列的映射
		 id = IntegerField('id')
		 name = StringField('username')
		 email = StringField('email')
		 password = StringField('password')

	 # 创建一个实例
	 u = User(id=12345, name='Michael', email='test@163.com', password='mypass')
	 # 保存到数据库
	 u.save()
   #+END_SRC

其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者使用起来却异常简单。

现在，我们就按上面的接口来实现该ORM。首先来定义Field类，它负责保存数据库表的字段名和字段类型：
   #+BEGIN_SRC python :results output :exports both
	 class Field:
		 def __init__(self, name, column_type):
			 self.name = name
			 self.column_type = column_type

		 def __str__(self):
			 return '<{}:{}>'.format(self.__class__.__name__, self.name)
   #+END_SRC

在Field的基础上，进一步定义各种类型的Field，比如StringField、IntegerField等等：
   #+BEGIN_SRC python :results output :exports both
	 class StringField(Field):
		 def __init__(self, name):
			 super(StringField, self).__init__(name, 'varchar(100)')


	 class IntegerField(Field):
		 def __init__(self, name):
			 super(IntegerField, self).__init__(name, 'bigint')
   #+END_SRC

下一步，就是编写最复杂的ModelMetaclass了：
   #+BEGIN_SRC python :results output :exports both
	 class ModelMetaclass(type):
		 def __new__(cls, name, bases, attrs):
			 if name == 'Model':
				 return type.__new__(cls, name, bases, attrs)
			 print('Fond model: {}'.format(name))
			 mappings = dict()
			 for k, v in attrs.items():
				 if isinstance(v, Field):
					 print('Found mapping: {} ==> {}'.format(k, v))
					 mappings[k] = v
			 for k in mappings.keys():
				 attrs.pop(k)
			 attrs['__mappings__'] = mappings
			 attrs['__table__'] = name
			 return type.__new__(cls, name, bases, attrs)
   #+END_SRC

编写基类Model：
   #+BEGIN_SRC python :results output :exports both
	 class Model(dict, metaclass=ModelMetaclass):
		 def __init__(self, **kw):
			 super(Model, self).__init__(**kw)

		 def __getattr__(self, key):
			 try:
				 return self[key]
			 except KeyError:
				 raise AttributeError(r"'Model' object has no attribute '{}'".format(key))

		 def __setattr__(self, key, value):
			 self[key] = value

		 def save(self):
			 fields = []
			 params = []
			 args = []
			 for k, v in self.__mappings__.items():
				 fields.append(v.name)
				 params.append('?')
				 args.append(getattr(self, k, None))
			 sql = 'INSERT INTO {} ({}) VALUES ({})'.format(self.__table__, ','.join(fields), ','.joins(params))
			 print('SQL: {}'.format(sql))
			 print('ARGS: {}'.format(str(args)))
   #+END_SRC

当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。

在ModelMetaclass中，一共做了几件事情：
1. 排除掉对Model类的修改；
2. 在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个mappings的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；
3. 把表名保存到table中，这里简化为表名默认为类名。

我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。

整个代码如下：
   #+BEGIN_SRC python :results output :exports both
	 class Field:
		 def __init__(self, name, column_type):
			 self.name = name
			 self.column_type = column_type

		 def __str__(self):
			 return '<{}:{}>'.format(self.__class__.__name__, self.name)


	 class StringField(Field):
		 def __init__(self, name):
			 super(StringField, self).__init__(name, 'varchar(100)')


	 class IntegerField(Field):
		 def __init__(self, name):
			 super(IntegerField, self).__init__(name, 'bigint')


	 class ModelMetaclass(type):
		 def __new__(cls, name, bases, attrs):
			 if name == 'Model':
				 return type.__new__(cls, name, bases, attrs)
			 print('Found model: {}'.format(name))
			 mappings = dict()
			 for k, v in attrs.items():
				 if isinstance(v, Field):
					 print('Found mapping: {} ==> {}'.format(k, v))
					 mappings[k] = v
			 for k in mappings.keys():
				 attrs.pop(k)
			 attrs['__mappings__'] = mappings
			 attrs['__table__'] = name
			 return type.__new__(cls, name, bases, attrs)


	 class Model(dict, metaclass=ModelMetaclass):
		 def __init__(self, **kw):
			 super(Model, self).__init__(**kw)

		 def __getattr__(self, key):
			 try:
				 return self[key]
			 except KeyError:
				 raise AttributeError(r"'Model' object has no attribute '{}'".format(key))

		 def __setattr__(self, key, value):
			 self[key] = value

		 def save(self):
			 fields = []
			 params = []
			 args = []
			 for k, v in self.__mappings__.items():
				 fields.append(v.name)
				 params.append('?')
				 args.append(getattr(self, k, None))
			 sql = 'INSERT INTO {} ({}) VALUES ({})'.format(self.__table__,
															','.join(fields),
															','.join(params))
			 print('SQL: {}'.format(sql))
			 print('ARGS: {}'.format(str(args)))


	 class User(Model):
		# 定义类的属性到列的映射：
		id = IntegerField('id')
		name = StringField('username')
		email = StringField('email')
		password = StringField('password')

	 if __name__ == '__main__':
		 u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
		 u.save()
   #+END_SRC

#+RESULTS:
: Found model: User
: Found mapping: id ==> <IntegerField:id>
: Found mapping: email ==> <StringField:email>
: Found mapping: name ==> <StringField:username>
: Found mapping: password ==> <StringField:password>
: SQL: INSERT INTO User (id,password,username,email) VALUES (?,?,?,?)
: ARGS: [12345, 'my-pwd', 'Michael', 'test@orm.org']

可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。

不到100行代码，我们就通过metaclass实现了一个精简的ORM框架。

metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。 这种强大的功能使用起来务必小心。
**** 元编程总结
元类可以做什么呢？
1. 当你问元类能做什么的时候，那么你不要使用元类；
2. 当你使用元类的时候，你应该清楚它能做什么；

一个使用元类的库，dpkt，

DNS反射攻击。

核心交换机 分光镜 到服务器 修改目标地址为PPE的地址
* 并发编程
并发 - 假同时 一段时间内同时处理多个任务，单核也可以并发

并行 - 真同时 同时处理过个任务，必须要多核

计算密集型与IO密集型

主流操作系统：
+ 线程
+ 进程

主流语言通常提供用户空间的调度：协程
** 多线程
*** 标准模块
  一个标准的模块是threading，简单的使用：
  #+BEGIN_SRC python
import threading


def worker():
  print('work')

# 创建线程对象，target参数是一个函数，这个函数即线程要执行的逻辑
thread = threading.Thread(target=worker)
# start方法启动一个线程，当这个线程的逻辑执行完毕的时候，线程自动退出，
# Python没有提供主动退出线程的方法
# 所以，一定要注意线程的退出
thread.start()
  #+END_SRC

  当然，也可以给目标函数传递参数，传递参数使用Thread方法的args参数，
  #+BEGIN_SRC python
import time


def worker(num):
  time.sleep(1)
  print('worker-{}'.format(num))

for x in range(5):
  t = threading.Thread(target=workder, args=(x,))
  t.start()
  #+END_SRC
  运行结果为：
  #+BEGIN_SRC python
# 输出结果比较乱
In [13]: worker-1worker-0
worker-4
worker-3worker-2
  #+END_SRC

  根据上面的输出结果可以看到，输出的顺序乱掉来了，通常不会使用print函数，而是使用
  logging来替代print，接下来演示如何使用：
  #+BEGIN_SRC python
In [24]: import logging

In [25]: logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s [%(threadName)s] %(message)s')

In [26]: def worker(num):
  ...:     logging.warning('worker-{}'.format(num))
  ...:

In [27]: for x in range(5):
  ...:     t = threading.Thread(target=worker, args=(x,))
  ...:     t.start()
  ...:
2017-03-24 15:51:57,651 WARNING [Thread-3986] worker-0
2017-03-24 15:51:57,653 WARNING [Thread-3987] worker-1
2017-03-24 15:51:57,653 WARNING [Thread-3988] worker-2
2017-03-24 15:51:57,658 WARNING [Thread-3989] worker-3
2017-03-24 15:51:57,664 WARNING [Thread-3990] worker-4
  #+END_SRC
*** 标识一个线程
  current_thread方法返回当前线程。一个例子：
  #+BEGIN_SRC python
In [20]: def xxx():
  ...:     print threading.current_thread()
  ...:

In [21]: threading.Thread(target=xxx).start()
<Thread(Thread-2945, started 8112)>

In [22]: thread = threading.current_thread()

In [23]: thread.is_alive()
Out[23]: True
  #+END_SRC
*** 线程参数
  目标函数的参数传递与一般函数相似，通过args参数传递位置参数，通过
  kwargs传递关键字参数。举个例子：
  #+BEGIN_SRC python
In [28]: def add(x, y):
  ...:     logging.info(x + y)
  ...:

In [29]: add(1, 2)
2017-03-24 15:58:01,796 INFO [MainThread] 3

In [30]: add(x=1, y=2)
2017-03-24 15:58:08,897 INFO [MainThread] 3

In [31]: threading.Thread(target=add, args=(1, 2)).start()

2017-03-24 15:58:30,036 INFO [Thread-4391] 3
In [32]: threading.Thread(target=add, kwargs={'x': 1, 'y': 2}).start()

2017-03-24 15:58:55,542 INFO [Thread-4601] 3
In [33]: threading.Thread(target=add, args=(1, ), kwargs={'y': 2}).start()

2017-03-24 15:59:23,230 INFO [Thread-4838] 3
  #+END_SRC
*** 控制线程名称
  通过name参数控制线程的名字。线程可以重名，线程名并不是线程的唯一标
  识，但是通常应该避免线程重名，通常的处理手段是加前缀。举例如下：
  #+BEGIN_SRC python
In [34]: threading.Thread(target=add, args=(1, 2), name='add').start()

2017-03-24 16:04:32,759 INFO [add] 3
In [35]: def worker():
  ...:     logging.info('starting')
  ...:     time.sleep(2)
  ...:     logging.info('completed')
  ...:

In [36]: t1 = threading.Thread(target=worker, name='worker')

In [37]: t2 = threading.Thread(target=worker, name='worker')

In [38]: t1.start() ; t2.start()
2017-03-24 16:05:57,640 INFO [worker] starting
2017-03-24 16:05:57,641 INFO [worker] starting
2017-03-24 16:05:59,641 INFO [worker] completed
2017-03-24 16:05:59,641 INFO [worker] completed

In [39]: t1 == t2
Out[39]: False
  #+END_SRC
*** 线程安全
*** daemon与non-daemon
*** treadlocal
*** 定时器/延迟执行
  #+BEGIN_SRC python :results output :exports both
	class Timer:
		def __init__(self, interval, function, *args, **kwargs):
			self.interval = interval
			self.function = function
  #+END_SRC
*** 线程同步
**** event
   #+BEGIN_SRC python :results output :exports both
	import threading
	import logging

	logging.basicConfig(level=logging.DEBUG,
						format='%(asctime)s %(levelname)s %(message)s')


	def worker(event: threading.Event):
		while not event.wait(3):
			logging.info('run run run')

	event = threading.Event()
	threading.Thread(target=worker, args=(event,), name='printer').start()
   #+END_SRC

   event用于线程之间发送信号。
**** lock
   #+BEGIN_SRC python :results output :exports both
	 import random
	 import threading
	 import logging

	 logging.basicConfig(level=logging.DEBUG,
						 format='%(asctime)s %(levelname)s %(message)s')


	 class Counter:
		 def __init__(self):
			 self.__val = 0
			 self._lock = threading.Lock()

		 @property
		 def value(self):
			 with self._lock:
				 return self.__val

		 def inc(self):
			 with self._lock:
				 self.__val += 1

		 def dec(self):
			 with self._lock:
				 self.__val -= 1

	 counter = Counter()


	 def fn():
		 if random.choice([-1, 1]) > 0:
			 logging.info('inc')
			 counter.inc()
		 else:
			 logging.info('dec')
			 counter.dec()

	 for x in range(10):
		 threading.Thread(target=fn).start()
   #+END_SRC

   #+RESULTS:

   再来一例：
   #+BEGIN_SRC python :results output :session :exports both
	 import threading
	 import logging

	 logging.basicConfig(level=logging.DEBUG,
						 format='%(asctime)s %(levelname)s %(message)s')


	 def worker(tasks):
		 for task in tasks:
			 if task.lock.acquire(False):
				 logging.info(task.name)


	 class Task:
		 def __init__(self, name):
			 self.name = name
			 self.lock = threading.Lock()

	 tasks = [Task(x) for x in range(10)]

	 for x in range(5):
		 threading.Thread(target=worker, args=(tasks,), name='worker-{}'.format(x)).start()

   #+END_SRC

#+RESULTS:
**** condition
#+BEGIN_SRC python :results output :exports both
import random
import threading
import logging

logging.basicConfig(level=logging.DEBUG,
					format='%(asctime)s %(levelname)s [%(threadName)s] %(message)s')


class Dispatcher:
	def __init__(self):
		self.data = None
		self.event = threading.Event()
		self.cond = threading.Condition()

	def consumer(self):
		while not self.event.is_set():
			with self.cond:
				self.cond.wait()
				logging.info(self.data)

	def producer(self):
		for _ in range(10):
			data = random.randint(0, 100)
			logging.info(data)
			self.data = data
			with self.cond:
				self.cond.notify()
			self.event.wait(1)
		self.event.set()

d = Dispatcher()

p = threading.Thread(target=d.producer, name='producer')

for x in range(4):
	threading.Thread(target=d.consumer, name='consumer-{}'.format(x)).start()

#+END_SRC
** 多进程
1. fork
2. multiprocess
3. 进程间通信
* 网络编程
* Web编程
** 增加过滤器
   增加Filter类，filter类可以在请求之前与请求之后做的处理，代码修改如下：
 #+BEGIN_SRC python
   # ccframe/__init__.py文件
   [lavenliu@VM_113_230_centos 12-web]$ cat ccframe/__init__.py 
   # coding: utf-8

   import re
   from functools import wraps
   from html import escape
   from collections import namedtuple
   # from webob import Response
   from webob.dec import wsgify
   from webob.exc import HTTPNotFound, HTTPTemporaryRedirect

   PATTERNS = {
     'str': '[^/].+',
     'word': '\w+',
     'any': '.+',
     'int': '[+-]?\d+',
     'float': '[+-]?\d\.\d+'
   }

   CASTING = {
     'str': str,
     'word': str,
     'any': str,
     'int': int,
     'float': float
   }

   Route = namedtuple('Route', ['pattern', 'methods', 'casting', 'handler'])


   class Router:
     def __init__(self, prefix='', domain=None, filters=None):
         self.routes = []
         self.domain = domain
         self.prefix = prefix
         if filters is None:
             filters = []
         self.filters = []
         for fl in filters:
             if isinstance(fl, Filter):
                 self.filters.append(fl)
             else:
                 raise Exception('{} is not a Filter'.format(fl))

     def _route(self, rule, methods, handler):
         pattern, casting = self._rule_parse(rule)
         self.routes.append(Route(re.compile(pattern),
                                  methods, casting, handler))

     def _rule_parse(self, rule):
         # TODO
         pattern = []
         spec = []
         casting = {}
         is_spec = False
         for c in rule:
             if c == '{' and not is_spec:
                 is_spec = True
             elif c == '}' and is_spec:
                 is_spec = False
                 name, p, c = self._spec_parse(''.join(spec))
                 spec = []
                 pattern.append(p)
                 casting[name] = c
             elif is_spec:
                 spec.append(c)
             else:
                 pattern.append(c)
         return '{}$'.format(''.join(pattern)), casting

     def _spec_parse(self, src):
         tmp = src.split(':')
         if len(tmp) > 2:
             raise Exception('error pattern')
         name = tmp[0]
         name_type = 'str'
         if len(tmp) == 2:
             name_type = tmp[1]
         pattern = '(?P<{}>{})'.format(name, PATTERNS[name_type])
         return name, pattern, CASTING[name_type]

     def route(self, pattern, methods=None):
         if methods is None:
             methods = ('GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTION')

         def dec(fn):
             self._route(pattern, methods, fn)
             return fn
         return dec

     def _domain_match(self, request):
         return self.domain is None or re.match(self.domain, request.host)

     def _prefix_match(self, request):
         return request.path.startswith(self.prefix)

     def _apply_filter(self, handler):
         @wraps(handler)
         def apply(ctx, request):
             for fl in self.filters:
                 request = fl.before_request(ctx, request)
             response = handler(ctx, request)
             for fl in reversed(self.filters):
                 response = fl.after_request(ctx, response)
             return response
         return apply

     def match(self, request):
         if self.domain is None or re.match(self.domain, request.host()):
             if request.path.startswith(self.prefix):
                 for route in self.routes:
                     if request.method in route.methods:
                         m = route.pattern.match(
                             request.path.replace(self.prefix, '', 1))
                         if m:
                             request.args = {}
                             for k, v in m.groupdict().items():
                                 request.args[k] = route.casting[k](v)
                             return self._apply_filter(route.handler)


   class Application:
     def __init__(self, routers=None, **options):
         if routers is None:
             self.routers = []
         self.routers = routers
         self.options = options

     def add_router(self, router):
         self.routers.append(router)

     @wsgify
     def __call__(self, request):
         for router in self.routers:
             handler = router.match(request)
             if handler:
                 return handler(self, request)
         raise HTTPNotFound(detail='no handler match')


   # add filter
   class Filter:
     def before_request(self, ctx, request):
         return request

     def after_request(self, ctx, response):
         return response

   # ccframe/utils.py
   [lavenliu@VM_113_230_centos 12-web]$ cat ccframe/utils.py 
   import json
   from webob import Response


   def jsonfy(**kwargs):
     return Response(json.dumps(kwargs),
                     content_type='application/json')

   # app-filter.py
   [lavenliu@VM_113_230_centos 12-web]$ cat app-filter.py 
   import jwt
   import json
   import datetime
   import logging
   import threading
   from ccframe import Router, Application, Filter
   from ccframe.utils import jsonfy
   from webob import Response
   from functools import wraps
   from webob.exc import HTTPUnauthorized

   __KEY = 'xxxyyyyzzzzz'
   logging.basicConfig(level=logging.INFO)


   class AccessLogFilter(Filter):
     def __init__(self):
         self.local = threading.local()
         self.local.start = None
         self.local.request = None

     def before_request(self, ctx, request):
         self.local.start = datetime.datetime.now()
         self.local.request = request
         return request

     def after_request(self, ctx, response):
         now = datetime.datetime.now()
         time = (now - self.local.start).total_seconds()
         logging.info(str(time))
         return response

   router = Router(filters=[AccessLogFilter()])


   def authenticated(fn):
     @wraps(fn)
     def wrap(ctx, request):
         token = request.headers.get('X-Authorization-Token')
         if token is None:
             raise HTTPUnauthorized()
         try:
             decoded = jwt.decode(token, __KEY, ['HS512'])
             user = decoded.get('user')
             if user is None:
                 raise HTTPUnauthorized()
             request.user = user
             return fn(ctx, request)
         except Exception:
             raise HTTPUnauthorized()
     return wrap


   @router.route('/')
   @authenticated
   def main(ctx, request):
     return Response('hello world')


   @router.route('/login', methods=['POST'])
   def login(ctx, request):
     payload = json.loads(request.body.decode())
     if payload.get('username') == 'lavenliu' and \
        payload.get('password') == 'pass':
         exp = datetime.datetime.utcnow() + datetime.timedelta(hours=8)
         token = jwt.encode({'user': 'lavenliu',
                             'exp': exp},
                            __KEY,
                            'HS512').decode()
         # return Response(json.dumps({'token': token}),
         #                 content_type='application/json')
         return jsonfy(code=200, token=token)
     # return Response(json.dumps(
     #     {'code': 401, 'message': 'username or password not matched'}),
     #                 content_type='application/json')
     return jsonfy(code=401, message='username or password not matched')


   app = Application([router])

   if __name__ == "__main__":
     from wsgiref.simple_server import make_server

     server = make_server('0.0.0.0', 3001, app)
     try:
         server.serve_forever()
     except KeyboardInterrupt:
         server.shutdown()
 #+END_SRC

运行代码，
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 12-web]$ python app-filter.py 
INFO:root:0.000506
127.0.0.1 - - [17/Oct/2016 21:51:13] "POST /login HTTP/1.1" 200 198
 #+END_SRC

在命令行使用curl验证，运行结果为：
 #+BEGIN_SRC sh
[root@VM_113_230_centos ~]# curl -XPOST http://127.0.0.1:3001/login -d '{"username": "lavenliu", "password": "pass"}'
{"token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJleHAiOjE0NzY3NDEwNzMsInVzZXIiOiJsYXZlbmxpdSJ9.BlCkpad1qQkkz66nPkUYfuRmJA0092xKTIG9KdMT2tlbQeuH8H-vfEZGBs9MA7uBlfYLgiCOU5rDxRfNi20UJg", "code": 200}
[root@VM_113_230_centos ~]#
 #+END_SRC
** 实现通用认证
客户端带着身份信息访问网站，不然就不好做认证了。哪些方法可以带身份
信息过来呢？

客户端带着信息过来，服务端进行验证。
** 总结
** 20170325
对这个例子的形象描述：
 #+BEGIN_EXAMPLE
Application CTO

request是产品需求

Router是总监

Route是员工

CTO 收到一个产品需求， 挨个去问总监，你能处理这个需求吗？总监根据前缀判断是否可以处理

总监如果可以处理，他接收这个需求，然后挨个去问员工， 你能处理这个需求吗？ 员工根据路由规则判断能否处理，如果能， 处理这个需求

上述的设计思路是“责任链”的设计模式，属于设计模式的一种。
 #+END_EXAMPLE

整体代码：
 #+BEGIN_SRC python :results output :exports both
import re
from webob import Request, Response
from webob import exc
from webob.dec import wsgify


PATTERNS = {
  'str': r'[^/]+',
  'word': r'\w+',
  'int': r'[+-]?\d+',
  'float': r'[+-]?\d+\.\d+',
  'any': r'.+'
}

TRANSLATORS = {
  'str': str,
  'word': str,
  'any': str,
  'int': int,
  'float': float
}


class _Vars:
  def __init__(self, data=None):
	  if data is not None:
		  self._data = data
	  else:
		  self._data = {}

  def __getattr__(self, item):
	  try:
		  return self._data[item]
	  except KeyError:
		  raise AttributeError('no attribute {}'.format(item))

  def __setattr__(self, key, value):
	  if key != '_data':
		  raise NotImplemented
	  self.__dict__['_data'] = value


class Route:
  __slots__ = ['methods', 'pattern', 'translator', 'handler']

  def __init__(self, pattern, translator, methods, handler):
	  self.pattern = re.compile(pattern)
	  if translator is None:
		  translator = {}
	  self.translator = translator
	  self.methods = methods
	  self.handler = handler

  def run(self, prefix: str, request: Request):
	  if self.methods:
		  if isinstance(self.methods, (list, tuple, set)) and request.method not in self.methods:
			  return
		  if isinstance(self.methods, str) and self.methods != request.method:
			  return
	  m = self.pattern.match(request.path.replace(prefix, '', 1))
	  if m:
		  vs = {}
		  for k, v in m.groupdict().items():
			  vs[k] = self.translator[k](v)
			  # request.params.add(k, vs[k])
		  request.vars = _Vars(vs)
		  return self.handler(request)


class Router:
  def __init__(self, prefix=''):
	  self.__prefix = prefix.rstrip('/')
	  self._routes = []

  @property
  def prefix(self):
	  return self.__prefix

  def _rule_parse(self, rule: str, methods, handler) -> Route:
	  pattern = ['^']
	  spec = []
	  translator = {}
	  # /home/{name:str}/{id:int}
	  is_spec = False
	  for c in rule:
		  if c == '{':
			  is_spec = True
		  elif c == '}':
			  is_spec = False
			  name, pat, t = self._spec_parse(''.join(spec))
			  pattern.append(pat)
			  translator[name] = t
			  spec.clear()
		  elif is_spec:
			  spec.append(c)
		  else:
			  pattern.append(c)
	  pattern.append('$')
	  return Route(''.join(pattern), translator, methods, handler)

  @staticmethod
  def _spec_parse(spec: str):
	  name, _, type = spec.partition(':')
	  if not name.isidentifier():
		  raise Exception('name {} is not identifier'.format(name))
	  if type not in PATTERNS.keys():
		  type = 'word'
	  pattern = '(?P<{}>{})'.format(name, PATTERNS[type])
	  return name, pattern, TRANSLATORS[type]

  def route(self, rule, methods=None):
	  def wrap(handler):
		  route = self._rule_parse(rule, methods, handler)
		  self._routes.append(route)
		  return handler
	  return wrap

  def get(self, pattern='.*'):
	  return self.route(pattern, 'GET')

  def put(self, pattern='.*'):
	  return self.route(pattern, 'PUT')

  def post(self, pattern='.*'):
	  return self.route(pattern, 'POST')

  def delete(self, pattern='.*'):
	  return self.route(pattern, 'DELETE')

  def patch(self, pattern='.*'):
	  return self.route(pattern, 'PATCH')

  def head(self, pattern='.*'):
	  return self.route(pattern, 'HEAD')

  def options(self, pattern='.*'):
	  return self.route(pattern, 'OPTIONS')

  def run(self, request: Request):
	  if not request.path.startswith(self.prefix):
		  return
	  for route in self._routes:
		  res = route.run(self.prefix, request)
		  if res:
			  return res


class Application:
  ROUTERS = []

  @classmethod
  def register(cls, router: Router):
	  cls.ROUTERS.append(router)

  @wsgify
  def __call__(self, request: Request) -> Response:
	  for router in self.ROUTERS:
		  response = router.run(request)
		  if response:
			  return response
	  raise exc.HTTPNotFound('not found')


shop = Router('/shop')


@shop.get('/{id:int}')
def get_product(request: Request):
  print(request.vars.id)
  print(type(request.vars.id))
  return Response(body='product {}'.format(request.vars.id), content_type='text/plain')


Application.register(router=shop)


if __name__ == '__main__':
  from wsgiref.simple_server import make_server

  server = make_server('0.0.0.0', 8000, Application())
  try:
	  server.serve_forever()
  except KeyboardInterrupt:
	  server.shutdown()


# /hello?name=comyn => hello comyn
# / => hello world
# /hello/(\w+)  request.args[0]
# /hello/(?P<name>\w+)  request.kwargs.name
# @get('/hello/(?P<name>\w+)')

# shop = Router('/shop')
# shop.get('/(?P<id>\d+)') = /shop/12345

# /home/{name:str}/{id:int}  str, word(\w+), int, float, any  request.vars request.params path > qs
 #+END_SRC
* ORM
ORM(Object Relational Mapping): 对象关系映射。将数据库的操作用面向对
象的程序方法实现。

+ 易改：便于更换数据库，SQL语句是由底层根据数据库类型生成的，上层数
据模型无需变化
+ 易用：便于对数据模型进行操作，创建，更新，查询，删除。用户编写简单，
无须写SQL语句即可操作数据
+ 易看：使数据模型的程序文档化，便于维护
** MySQL基本操作
保持长连接；启动的时候创建连接，结束的时候关闭连接。
 #+BEGIN_SRC sql
mysql -hlocalhost -uroot -pheli123456
create database demo;
-- book, author,
CREATE TABLE `author` (
`id` bigint(20) NOT NULL AUTO_INCREMENT,
`name` varchar(45) NOT NULL,
`country` varchar(45) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

mysql> create table author(id bigint(20) not null primary key, name varchar(45) not null, country varchar(45));
Query OK, 0 rows affected (0.03 sec)

mysql> desc author;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| id      | bigint(20)  | NO   | PRI | NULL    |       |
| name    | varchar(45) | NO   |     | NULL    |       |
| country | varchar(45) | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec) 
create table author (
id bigint(20) not null auto_increment,
name varchar(45) not null,
country varchar(45) null,
primary key ('id'),
index author_name_INDEX (name ASC)
);
 #+END_SRC

使用游标对象操作数据库。

例子：
 #+BEGIN_SRC python
import pymysql


conn = pymysql.connect(host='127.0.0.1',
					 user='root',
					 password='helin123456',
					 database='demo')
try:
  with conn as cur:
	  # cur.execute("""insert into `author`(`name`, `country`) values("James", "America")""")
	  # cur.execute("""insert into `author`(`name`, `country`) values("Laven", "China")""")
	  # cur.execute("""update author set `name`='taoqi' where `id`=2""")
	  # cur.execute("""delete from `author` where `id`=3""")
	  # results = cur.execute("""select * from `author`""") # 返回值是受影响的行数
	  # results = cur.fetchall()   # 返回所有的结果，结果为嵌套的元组
	  # results = cur.fetchone()   # 返回第一条结果，结果为单个元组
	  # results = cur.fetchmany(3) # 返回指定的结果数量，结果为元组
	  print(results)
finally:
  conn.close()
 #+END_SRC

无论是哪个fetch函数，结果都已经返回到客户端了；fetch只是把所有的返
回结果进行筛选了而已。一般SQL语句与limit配合使用。

如果返回值要显式字段名呢？可以让返回结果为字典：
 #+BEGIN_SRC python
import pymysql
from pymysql.cursors import DictCursor


conn = pymysql.connect(host='127.0.0.1',
					 user='root',
					 password='helin123456',
					 database='demo',
					 cursorclass=DictCursor)
try:
  with conn as cur:
	  # cur.execute("""insert into `author`(`name`, `country`) values("James", "America")""")
	  # cur.execute("""insert into `author`(`name`, `country`) values("Laven", "China")""")
	  # cur.execute("""update author set `name`='taoqi' where `id`=2""")
	  # cur.execute("""delete from `author` where `id`=3""")
	  cur.execute("""select * from `author`""")
	  results = cur.fetchmany(3)
	  print(results)
finally:
  conn.close()
 #+END_SRC
** PyMySQL基本使用
#+BEGIN_SRC python :results output :exports both
import pymysql
conn = pymysql.connect(host='127.0.0.1', user='root', password='xxxxxx', port=3306, database='demo')
cur = conn.cursor()
cur.execute('''INSERT INTO `user`(`name`, `age`) VALUE('lavenliu', 18)''')
conn.commit()
#+END_SRC

非查询性请求的四个步骤：
1. 创建连接
2. 获取游标
3. 执行SQL
4. 提交事务

游标对象在close之前，可以反复使用：
#+BEGIN_SRC python :results output :exports both
cur = conn.cursor()
cur.execute('''SELECT * FROM `user` WHERE `age` <= 18''')
cur.fetchall() # fetch数据，返回所有数据
cur.execute('''SELECT * FROM `user` WHERE `age` <= 18''')
cur.fetchmany(1) # 指定返回数据的行数
cur.fetchone() # 返回一行数据
#+END_SRC

几个fetch方法的区别：
1. fetchall返回行的元组
2. fetchmany返回行的元组，可以指定返回前N行，相当于fetchall[:N]
3. fetchone返回首行，相当于fetchall[0]
** 实现连接池
目前的连接只有一个，在高并发的环境，效率就不会高。

接下来要实现一个连接池，保存一些连接，并且标记连接的状态；创建连接，
关闭连接；检测连接可用性；
 #+BEGIN_SRC python
import pymysql
import queue
from pymysql.cursors import DictCursor


class ConnectionPool:
  def __init__(self, **kwargs):
	  self.size = kwargs.pop('size', 10)
	  self.idle = kwargs.pop('idle', 3)
	  self.kwargs = kwargs
	  self.length = 0
	  self.connections = queue.Queue(maxsize=self.size)

  def _connect(self):
	  if not self.connections.full():
		  conn = pymysql.connect(**self.kwargs)
		  self.connections.put(conn)
		  self.length += 1
	  else:
		  raise RuntimeError('lot of connections')

  def _close(self, conn):
	  conn.close()
	  self.length -= 1

  def get(self, timeout=None):
	  if self.connections.empty() and self.length < self.size:
		  self._connect()
	  return self.connections.get(timeout=timeout)

  def return_resource(self, conn):
	  if self.connections.full():
		  self._close(conn)
		  return
	  self.connections.put(conn)


if __name__ == '__main__':
  pool = ConnectionPool(host='127.0.0.1',
						port=3306,
						user='root',
						password='helin123456',
						database='demo',
						cursorclass=DictCursor)

  conn = pool.get()
  try:
	  with conn as cur:
		  cur.execute("""select * from `author`""")
		  for res in cur.fetchall():
			  print(res)
  finally:
	  pool.return_resource(conn)
 #+END_SRC

运行效果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python pool.py 
{'name': 'taoqi', 'country': 'America', 'id': 2}
{'name': 'lavenliu', 'country': 'China', 'id': 4}
{'name': 'lavenliu', 'country': 'China', 'id': 5}
{'name': 'lavenliu', 'country': 'China', 'id': 6}
{'name': 'lavenliu', 'country': 'China', 'id': 7}
{'name': 'lavenliu', 'country': 'China', 'id': 8}
{'name': 'lavenliu', 'country': 'China', 'id': 9}
{'name': 'lavenliu', 'country': 'China', 'id': 10}
{'name': 'lavenliu', 'country': 'China', 'id': 11}
{'name': 'lavenliu', 'country': 'China', 'id': 12}
{'name': 'lavenliu', 'country': 'China', 'id': 13}
{'name': 'lavenliu', 'country': 'China', 'id': 14}
{'name': 'lavenliu', 'country': 'China', 'id': 15}
{'name': 'lavenliu', 'country': 'China', 'id': 16}
{'name': 'lavenliu', 'country': 'China', 'id': 17}
{'name': 'lavenliu', 'country': 'China', 'id': 18}
{'name': 'lavenliu', 'country': 'China', 'id': 19}
{'name': 'lavenliu', 'country': 'China', 'id': 20}
 #+END_SRC

使用netstat查看系统的连接情况：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ netstat -antup |grep 3306
(No info could be read for "-p": geteuid()=1001 but you should be root.)
tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4599      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4100      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:2965      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4832      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:3153      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4941      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:3575      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:3530      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4115      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4392      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:1349      TIME_WAIT   -                   
tcp        0      0 10.105.113.230:3306     180.97.215.25:4209      TIME_WAIT   - 
 #+END_SRC

如何让它变得更好用？引入上下文管理：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat pool_context_manager.py 
import pymysql
import queue
from contextlib import contextmanager
from pymysql.cursors import DictCursor


class ConnectionPool:
  def __init__(self, **kwargs):
	  self.size = kwargs.pop('size', 10)
	  self.idle = kwargs.pop('idle', 3)
	  self.kwargs = kwargs
	  self.length = 0
	  self.connections = queue.Queue(maxsize=self.size)

  def _connect(self):
	  if not self.connections.full():
		  conn = pymysql.connect(**self.kwargs)
		  self.connections.put(conn)
		  self.length += 1
	  else:
		  raise RuntimeError('lot of connections')

  def _close(self, conn):
	  conn.close()
	  self.length -= 1

  def get(self, timeout=None):
	  if self.connections.empty() and self.length < self.size:
		  self._connect()
	  conn = self.connections.get(timeout=timeout)
	  conn.ping(reconnect=True)
	  return conn

  def return_resource(self, conn):
	  if self.connections.full():
		  self._close(conn)
		  return
	  self.connections.put(conn)

  @contextmanager
  def __call__(self, timeout=None):
	  conn = self.get(timeout)
	  try:
		  yield conn.cursor()
		  conn.commit()
	  except:
		  conn.rollback()
	  finally:
		  self.return_resource(conn)


if __name__ == '__main__':
  pool = ConnectionPool(host='127.0.0.1',
						port=3306,
						user='root',
						password='helin123456',
						database='demo',
						cursorclass=DictCursor)

  # conn = pool.get()
  # try:
  #     with conn as cur:
  #         cur.execute("""select * from `author`""")
  #         for res in cur.fetchall():
  #             print(res)
  # finally:
  #     pool.return_resource(conn)

  # with pool() as conn:
  #     with conn as cur:
  #         cur.execute("""select * from `author`""")
  #         for ret in cur.fetchall():
  #             print(ret)

  with pool() as cur:
	  cur.execute("""select * from `author`""")
	  for ret in cur.fetchall():
		  print(ret)
 #+END_SRC
** ORM实现
 #+BEGIN_SRC python
# filename: orm1.py
[lavenliu@VM_113_230_centos 13-orm]$ cat orm1.py 
import datetime
from pymysql.cursors import DictCursor
from pool_context_manager import ConnectionPool


class Field:
  '''增加此类的目的是：判断插入的数据是否是Field类型'''
  pass


class Model:
  pass


class Author(Model):
  __table__ = 'author'

  id = Field()
  name = Field()
  country = Field()

  def __init__(self, **kwargs):
	  self.id = kwargs.get('id')
	  self.name = kwargs.get('name')
	  self.country = kwargs.get('country')

# select -> instance
# insert
# ORM => Object, RDBMS, Mapping


class DB:
  def __init__(self, **kwargs):
	  self.pool = ConnectionPool(**kwargs)

  def insert(self, instance):
	  if not isinstance(instance, Model):
		  raise Exception('{} is not instance of Model'.format(instance.__class__))
	  fields = []
	  values = []
	  # 只有字段正确时，才操作数据库
	  for field_name, field in instance.__class__.__dict__.items():
		  if isinstance(field, Field):
			  v = getattr(instance, field_name)
			  if v is not None and isinstance(v, (int, float, str, datetime.datetime)):
				  fields.append('`{}`'.format(field_name))
				  if isinstance(v, (int, float)):
					  values.append(str(v))
				  if isinstance(v, str):
					  values.append('"{}"'.format(v))
				  if isinstance(v, datetime.datetime):
					  values.append('"{}"'.format(v.isoformat()))
	  sql = '''insert into `{}`({}) value({})'''.format(
		  instance.__table__,
		  ', '.join(fields),
		  ', '.join(values))
	  print(sql)
	  with self.pool() as cur:
		  cur.execute(sql)


if __name__ == '__main__':
  db = DB(host='127.0.0.1',
		  port=3306,
		  user='root',
		  password='helin123456',
		  database='demo',
		  cursorclass=DictCursor)

  author = Author(name='cc', country='China')
  author.haha = 'haha'
  db.insert(author)
  # 执行之后，会打印如下SQL语句
  # insert into `author`(`name`, `country`) value("cc", "China")
  # the following call is error
  # class A:
  #     pass

  # db.insert(A())
 #+END_SRC

issubclass

加入了多种判断机制，以保证SQL的规范，代码如下：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat orm1.py 
import datetime
from pymysql.cursors import DictCursor
from pool_context_manager import ConnectionPool


class Field:
  def __init__(self,
			   name=None,
			   pk=False,
			   nullable=True,
			   index=False,
			   unique=False):
	  self.name = name
	  self.pk = pk
	  self.nullable = nullable
	  self.index = index
	  self.unique = unique
	  self._name = None

  def to_sql(self, value):
	  raise NotImplementedError()

  def validate(self, value):
	  return True, ''

  def __get__(self, instance, owner):
	  if instance is None:
		  return owner
	  return instance.__dict__[self._name]

  def __set__(self, instance, value):
	  ok, msg = self.validate(value)
	  if not ok:
		  raise TypeError(msg)
	  instance.__dict__[self._name] = value


class IntField(Field):
  def __init__(self,
			   name=None,
			   pk=False,
			   nullable=True,
			   index=False,
			   unique=False,
			   auto_inc=False):
	  super().__init__(name, pk, nullable, index, unique)
	  self.auto_inc = auto_inc

  def to_sql(self, value):
	  return str(value)

  def validate(self, value):
	  if value is not None and not isinstance(value, int):
		  return False, 'require type int, but {}'.format(type(value))
	  return True, ''


class StringField(Field):
  def __init__(self,
			   name=None,
			   pk=False,
			   nullable=False,
			   index=False,
			   unique=False,
			   length=45):
	  super().__init__(name, pk, nullable, index, unique)
	  self.length = length

  def to_sql(self, value):
	  return '"{}"'.format(value)

  def validate(self, value):
	  if value is not None:
		  if isinstance(value, str):
			  if len(value) <= self.length:
				  return True, ''
			  return False, 'max length is {}, but {}'.format(self.length, len(value))
		  return False, 'require str, but {}'.format(type(value))
	  return True, ''


class Meta(type):
  def __new__(cls, name, bases, attrs):
	  mapping = []
	  pk = []
	  for k, v in attrs.items():
		  if isinstance(v, Field):
			  v._name = k
			  if v.pk:
				  pk.append(v)
			  mapping.append(v)
	  attrs['__mapping__'] = mapping
	  attrs['__pk__'] = pk
	  return super().__new__(cls, name, bases, attrs)


class Model(metaclass=Meta):
  pass


class Author(Model):
  __table__ = 'author'

  id = IntField(pk=True)
  name = StringField()
  country = StringField()

  def __init__(self, **kwargs):
	  self.id = kwargs.get('id')
	  self.name = kwargs.get('name')
	  self.country = kwargs.get('country')

# select -> instance
# insert
# ORM => Object, RDBMS, Mapping


class DB:
  def __init__(self, **kwargs):
	  self.pool = ConnectionPool(**kwargs)

  def insert(self, instance):
	  if not isinstance(instance, Model):
		  raise Exception('{} is not instance of Model'.format(instance.__class__))
	  fields = []
	  values = []
	  for field_name, field in instance.__class__.__dict__.items():
		  if isinstance(field, Field):
			  v = getattr(instance, field_name)
			  if v is not None and isinstance(v, (int, float, str, datetime.datetime)):
				  fields.append('`{}`'.format(field_name))
				  if isinstance(v, (int, float)):
					  values.append(str(v))
				  if isinstance(v, str):
					  values.append('"{}"'.format(v))
				  if isinstance(v, datetime.datetime):
					  values.append('"{}"'.format(v.isoformat()))
	  sql = '''insert into `{}`({}) value({})'''.format(
		  instance.__table__,
		  ', '.join(fields),
		  ', '.join(values))
	  print(sql)
	  with self.pool() as cur:
		  cur.execute(sql)


if __name__ == '__main__':
  db = DB(host='127.0.0.1',
		  port=3306,
		  user='root',
		  password='helin123456',
		  database='demo',
		  cursorclass=DictCursor)

  # a right sql statement
  author = Author(name='cc', country='China')
  # an error sql statement, name is string, but here is int
  author = Author(name=18, country='China')
  author.haha = 'haha'
  db.insert(author)

  # the following call is error
  # class A:
  #     pass

  # db.insert(A())
 #+END_SRC

运行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python orm1.py 
Traceback (most recent call last):
File "orm1.py", line 158, in <module>
  author = Author(name=18, country='China')
File "orm1.py", line 110, in __init__
  self.name = kwargs.get('name')
File "orm1.py", line 34, in __set__
  raise TypeError(msg)
TypeError: require str, but <class 'int'>
 #+END_SRC
** ORM实现-20170408
#+BEGIN_SRC python :results output :exports both
class Filed:
	def __init__(self,
				 name,
				 column=None,
				 primary_key=False,
				 unique=False,
				 index=False,
				 nullable=True,
				 default=None):
		self.name = name
		self.column = column
		self.primary_key = primary_key
		self.unique = unique
		self.index = index
		self.nullable = nullable
		self.default = default

	def validate(self, value):
		raise NotImplemented

	def __get__(self, instnace, cls):
		if instnace is None:
			return self
		return
#+END_SRC
** SQLAchemy基础
** SQLAchemy之1对多关系
修改之前的代码，如下：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_one_to_n.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  # 注意：前后要一致，首尾相应
  addresses = relationship('Address', back_populates='user')

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  # 注意：前后要一致，首尾相应
  user = relationship('User', back_populates='addresses')

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  Model.metadata.drop_all(engine)
  Model.metadata.create_all(engine)
 #+END_SRC

接着执行该脚本，生成相应的表。执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_one_to_n.py 
2016-11-20 19:19:37,087 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-11-20 19:19:37,087 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,089 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-11-20 19:19:37,090 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,091 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-11-20 19:19:37,091 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,093 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-11-20 19:19:37,093 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,093 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-11-20 19:19:37,094 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,094 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-11-20 19:19:37,094 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,096 INFO sqlalchemy.engine.base.Engine DESCRIBE `users`
2016-11-20 19:19:37,096 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,097 INFO sqlalchemy.engine.base.Engine DESCRIBE `addresses`
2016-11-20 19:19:37,097 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,098 INFO sqlalchemy.engine.base.Engine 
DROP TABLE addresses
2016-11-20 19:19:37,099 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,110 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-20 19:19:37,110 INFO sqlalchemy.engine.base.Engine 
DROP TABLE users
2016-11-20 19:19:37,110 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,117 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-20 19:19:37,117 INFO sqlalchemy.engine.base.Engine DESCRIBE `users`
2016-11-20 19:19:37,117 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,118 INFO sqlalchemy.engine.base.Engine ROLLBACK
2016-11-20 19:19:37,118 INFO sqlalchemy.engine.base.Engine DESCRIBE `addresses`
2016-11-20 19:19:37,118 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,119 INFO sqlalchemy.engine.base.Engine ROLLBACK
2016-11-20 19:19:37,120 INFO sqlalchemy.engine.base.Engine 
CREATE TABLE users (
  id INTEGER NOT NULL AUTO_INCREMENT, 
  name VARCHAR(45) NOT NULL, 
  fullname VARCHAR(128), 
  password VARCHAR(128) NOT NULL, 
  PRIMARY KEY (id), 
  UNIQUE (name)
)


2016-11-20 19:19:37,120 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,122 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-20 19:19:37,123 INFO sqlalchemy.engine.base.Engine CREATE INDEX ix_users_fullname ON users (fullname)
2016-11-20 19:19:37,123 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,146 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-20 19:19:37,147 INFO sqlalchemy.engine.base.Engine 
CREATE TABLE addresses (
  id INTEGER NOT NULL AUTO_INCREMENT, 
  address VARCHAR(128) NOT NULL, 
  user_id INTEGER NOT NULL, 
  PRIMARY KEY (id), 
  UNIQUE (address), 
  FOREIGN KEY(user_id) REFERENCES users (id)
)


2016-11-20 19:19:37,147 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:19:37,149 INFO sqlalchemy.engine.base.Engine COMMIT
 #+END_SRC

接下来修改代码，进行插入数据，需要修改的地方为：
 #+BEGIN_SRC python
if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  # Model.metadata.drop_all(engine)
  # Model.metadata.create_all(engine)

  addresses = [Address(address='cc@laven.liu'), Address(address='lcc@163.com')]
  user = User(name='laven', fullname='laven liu', password='123456', addresses=addresses)
  print(user)
  print(user.addresses)
 #+END_SRC

执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_one_to_n.py 
User<id=None,name=laven,fullname=laven liu>
[Address<id=None,address=cc@laven.liu>, Address<id=None,address=lcc@163.com>]
 #+END_SRC

以上的输出数据并没有保存到数据库中，如果要保存到数据库中，要怎么操
作呢？在上述的代码基础上增加如下几行：
 #+BEGIN_SRC python
session.add(user) # User是主表
try:
  session.commit()
except Exception as e:
  session.rollback()
  raise e
 #+END_SRC

命令行的执行结果如下：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_one_to_n.py 
User<id=None,name=laven,fullname=laven liu>
[Address<id=None,address=cc@laven.liu>, Address<id=None,address=lcc@163.com>]
2016-11-20 19:37:02,474 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-11-20 19:37:02,474 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:37:02,475 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-11-20 19:37:02,475 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:37:02,476 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-11-20 19:37:02,476 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:37:02,478 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-11-20 19:37:02,478 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:37:02,478 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-11-20 19:37:02,478 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:37:02,479 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-11-20 19:37:02,479 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:37:02,480 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-11-20 19:37:02,495 INFO sqlalchemy.engine.base.Engine INSERT INTO users (name, fullname, password) VALUES (%(name)s, %(fullname)s, %(password)s)
2016-11-20 19:37:02,495 INFO sqlalchemy.engine.base.Engine {'password': '123456', 'fullname': 'laven liu', 'name': 'laven'}
2016-11-20 19:37:02,496 INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (address, user_id) VALUES (%(address)s, %(user_id)s)
2016-11-20 19:37:02,497 INFO sqlalchemy.engine.base.Engine {'user_id': 1, 'address': 'cc@laven.liu'}
2016-11-20 19:37:02,497 INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (address, user_id) VALUES (%(address)s, %(user_id)s)
2016-11-20 19:37:02,497 INFO sqlalchemy.engine.base.Engine {'user_id': 1, 'address': 'lcc@163.com'}
2016-11-20 19:37:02,498 INFO sqlalchemy.engine.base.Engine COMMIT
 #+END_SRC

数据库的执行结果如下：
 #+BEGIN_SRC sql
mysql> select * from users;
+----+-------+-----------+----------+
| id | name  | fullname  | password |
+----+-------+-----------+----------+
|  1 | laven | laven liu | 123456   |
+----+-------+-----------+----------+
1 row in set (0.00 sec)

mysql> select * from addresses;
+----+--------------+---------+
| id | address      | user_id |
+----+--------------+---------+
|  1 | cc@laven.liu |       1 |
|  2 | lcc@163.com  |       1 |
+----+--------------+---------+
2 rows in set (0.00 sec)
 #+END_SRC

看一种另外一种场景：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_one_to_n.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  addresses = relationship('Address', back_populates='user')

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  user = relationship('User', back_populates='addresses')

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  address = Address(address='air.man.six@gmail.com')
  user = session.query(User).filter(User.id == 1).first()
  address.user = user

  # Address is master table: N->1
  session.add(address)
  try:
	  session.commit()
  except Exception as e:
	  session.rollback()
	  raise e
 #+END_SRC

执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_one_to_n.py
2016-11-20 19:46:27,252 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-11-20 19:46:27,252 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:46:27,254 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-11-20 19:46:27,254 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:46:27,255 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-11-20 19:46:27,255 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:46:27,256 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-11-20 19:46:27,256 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:46:27,257 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-11-20 19:46:27,257 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:46:27,258 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-11-20 19:46:27,258 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 19:46:27,259 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-11-20 19:46:27,260 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password 
FROM users 
WHERE users.id = %(id_1)s 
LIMIT %(param_1)s
2016-11-20 19:46:27,260 INFO sqlalchemy.engine.base.Engine {'id_1': 1, 'param_1': 1}
2016-11-20 19:46:27,262 INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (address, user_id) VALUES (%(address)s, %(user_id)s)
2016-11-20 19:46:27,263 INFO sqlalchemy.engine.base.Engine {'user_id': 1, 'address': 'air.man.six@gmail.com'}
2016-11-20 19:46:27,263 INFO sqlalchemy.engine.base.Engine COMMIT
 #+END_SRC

数据库验证：
 #+BEGIN_SRC sql
mysql> select * from users;
+----+-------+-----------+----------+
| id | name  | fullname  | password |
+----+-------+-----------+----------+
|  1 | laven | laven liu | 123456   |
+----+-------+-----------+----------+
1 row in set (0.00 sec)

mysql> select * from addresses;
+----+-----------------------+---------+
| id | address               | user_id |
+----+-----------------------+---------+
|  1 | cc@laven.liu          |       1 |
|  2 | lcc@163.com           |       1 |
|  3 | air.man.six@gmail.com |       1 | # 新增的数据
+----+-----------------------+---------+
3 rows in set (0.00 sec)
 #+END_SRC

1:n与n:1是同一种东西，只是看有谁来驱动。由外键来决定，外键在N的那一
方，1的那一方是被引用的。

当外键字段设置unique索引的时候，就特化成了1:1了。

insert与update在ORM中几乎是一样的操作。

接下来看看多表查询。如进行下面的查询例子：
 #+BEGIN_EXAMPLE
找出用户的address是air.man.six@gmail.com。
 #+END_EXAMPLE
如果是使用SQL语句
 #+BEGIN_SRC sql
select * from users join addresses on users.id = addresses.user_id where addresses.address = 'air.man.six@gmail.com';
+----+-------+-----------+----------+----+-----------------------+---------+
| id | name  | fullname  | password | id | address               | user_id |
+----+-------+-----------+----------+----+-----------------------+---------+
|  1 | laven | laven liu | 123456   |  3 | air.man.six@gmail.com |       1 |
+----+-------+-----------+----------+----+-----------------------+---------+
1 row in set (0.00 sec)
 #+END_SRC

代码如下：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_one_to_n.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  addresses = relationship('Address', back_populates='user')

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  user = relationship('User', back_populates='addresses')

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  result = session.query(User).join(Address).filter(Address.address == 'air.man.six@gmail.com').all()
  print(result)
 #+END_SRC

执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_one_to_n.py
2016-11-20 20:04:38,795 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-11-20 20:04:38,797 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password 
FROM users INNER JOIN addresses ON users.id = addresses.user_id 
WHERE addresses.address = %(address_1)s
2016-11-20 20:04:38,797 INFO sqlalchemy.engine.base.Engine {'address_1': 'air.man.six@gmail.com'}
[User<id=1,name=laven,fullname=laven liu>]
 #+END_SRC

禁用外键的时候，把复杂性转移到了应用程序。应用程序可横向扩展，而DB
横向扩展比较困难。

接下来再看一种场景：
 #+BEGIN_SRC sql
select users.* from users
	 join addresses as a1 on users.id = a1.user_id
	 join addresses as a2 on users.id = a2.user_id
where a1.address = 'air.man.six@gmail.com' and a2.address = 'cc@laven.liu';
+----+-------+-----------+----------+
| id | name  | fullname  | password |
+----+-------+-----------+----------+
|  1 | laven | laven liu | 123456   |
+----+-------+-----------+----------+
1 row in set (0.00 sec)
 #+END_SRC
上面的SQL语句如何使用ORM写出来呢？代码如下：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_one_to_n.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship, aliased
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  addresses = relationship('Address', back_populates='user')

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  user = relationship('User', back_populates='addresses')

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  # result = session.query(User).join(Address).filter(Address.address == 'air.man.six@gmail.com').all()
  # result = session.query(User).join(Address, Address.user_id == User_id).filter(Address.address == 'air.man.six@gmail.com')
  # select users.* from users
  #     join addresses as a1 on users.id = a1.user_id
  #     join addresses as a2 on users.id = a2.user_id
  # where a1.address = 'air.man.six@gmail.com' and a2.address = 'cc@laven.liu';
  a1 = aliased(Address)
  a2 = aliased(Address)
  result = session.query(User)\
				  .join(a1, User.addresses)\
				  .join(a2, User.addresses)\
				  .filter(a1.address == 'air.man.six@gmail.com')\
				  .filter(a2.address == 'cc@laven.liu').all()
  print(result)
 #+END_SRC

执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_one_to_n.py
2016-11-20 20:44:00,276 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-11-20 20:44:00,276 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 20:44:00,278 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-11-20 20:44:00,278 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 20:44:00,278 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-11-20 20:44:00,279 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 20:44:00,280 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-11-20 20:44:00,280 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 20:44:00,281 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-11-20 20:44:00,281 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 20:44:00,282 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-11-20 20:44:00,282 INFO sqlalchemy.engine.base.Engine {}
2016-11-20 20:44:00,283 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-11-20 20:44:00,284 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password 
FROM users INNER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id INNER JOIN addresses AS addresses_2 ON users.id = addresses_2.user_id 
WHERE addresses_1.address = %(address_1)s AND addresses_2.address = %(address_2)s
2016-11-20 20:44:00,284 INFO sqlalchemy.engine.base.Engine {'address_1': 'air.man.six@gmail.com', 'address_2': 'cc@laven.liu'}
[User<id=1,name=laven,fullname=laven liu>] # 与SQL查询的结果一样
 #+END_SRC

接下来看多表多个关系的例子，上面的代码需要进行修改：
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_n_to_n.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship, aliased
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  addresses = relationship('Address', back_populates='user')
  managed_addresses = relationship('Address', back_populates='admin')

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
  admin_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  user = relationship('User', back_populates='addresses')
  admin = relationship('User', back_populates='managed_addresses')

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  Model.metadata.drop_all(engine)
  Model.metadata.create_all(engine)
 #+END_SRC

然后，重新生成新的表。执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_n_to_n.py 
2016-11-29 21:24:43,141 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-11-29 21:24:43,150 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,152 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-11-29 21:24:43,152 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,153 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-11-29 21:24:43,154 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,156 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-11-29 21:24:43,156 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,156 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-11-29 21:24:43,156 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,157 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-11-29 21:24:43,157 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,159 INFO sqlalchemy.engine.base.Engine DESCRIBE `addresses`
2016-11-29 21:24:43,159 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,185 INFO sqlalchemy.engine.base.Engine DESCRIBE `users`
2016-11-29 21:24:43,185 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,186 INFO sqlalchemy.engine.base.Engine 
DROP TABLE addresses
2016-11-29 21:24:43,187 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,232 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-29 21:24:43,233 INFO sqlalchemy.engine.base.Engine 
DROP TABLE users
2016-11-29 21:24:43,233 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,253 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-29 21:24:43,254 INFO sqlalchemy.engine.base.Engine DESCRIBE `addresses`
2016-11-29 21:24:43,254 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,255 INFO sqlalchemy.engine.base.Engine ROLLBACK
2016-11-29 21:24:43,255 INFO sqlalchemy.engine.base.Engine DESCRIBE `users`
2016-11-29 21:24:43,255 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,256 INFO sqlalchemy.engine.base.Engine ROLLBACK
2016-11-29 21:24:43,257 INFO sqlalchemy.engine.base.Engine 
CREATE TABLE users (
  id INTEGER NOT NULL AUTO_INCREMENT, 
  name VARCHAR(45) NOT NULL, 
  fullname VARCHAR(128), 
  password VARCHAR(128) NOT NULL, 
  PRIMARY KEY (id), 
  UNIQUE (name)
)


2016-11-29 21:24:43,257 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,260 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-29 21:24:43,260 INFO sqlalchemy.engine.base.Engine CREATE INDEX ix_users_fullname ON users (fullname)
2016-11-29 21:24:43,261 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,284 INFO sqlalchemy.engine.base.Engine COMMIT
2016-11-29 21:24:43,285 INFO sqlalchemy.engine.base.Engine 
CREATE TABLE addresses (
  id INTEGER NOT NULL AUTO_INCREMENT, 
  address VARCHAR(128) NOT NULL, 
  user_id INTEGER NOT NULL, 
  admin_id INTEGER NOT NULL, 
  PRIMARY KEY (id), 
  UNIQUE (address), 
  FOREIGN KEY(user_id) REFERENCES users (id), 
  FOREIGN KEY(admin_id) REFERENCES users (id)
)


2016-11-29 21:24:43,285 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:24:43,330 INFO sqlalchemy.engine.base.Engine COMMIT
 #+END_SRC

生成新的表后，插入一些测试数据，
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_n_to_n.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  addresses = relationship('Address', back_populates='user', foreign_keys="[Address.user_id]")
  managed_addresses = relationship('Address', back_populates='admin', foreign_keys="[Address.admin_id]")

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
  admin_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  user = relationship('User', back_populates='addresses', foreign_keys=[user_id])
  admin = relationship('User', back_populates='managed_addresses', foreign_keys=[admin_id])

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  # Model.metadata.drop_all(engine)
  # Model.metadata.create_all(engine)

  # insert some data to tables
  addresses = [Address(address='liu@laven.cn'), Address(address='lcc@163.com')]
  admin = User(name='laven', fullname='Liu cc', password='123456', managed_addresses=addresses)
  user = User(name='liu', fullname='CC Liu', password='123456', addresses=addresses)
  session.add(user)
  session.add(admin)

  try:
	  session.commit()
  except Exception as e:
	  session.rollback()
	  raise e
 #+END_SRC

执行结果如下：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_n_to_n.py 
2016-11-29 21:41:43,274 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-11-29 21:41:43,274 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:41:43,276 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-11-29 21:41:43,276 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:41:43,277 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-11-29 21:41:43,277 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:41:43,278 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-11-29 21:41:43,278 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:41:43,279 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-11-29 21:41:43,279 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:41:43,280 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-11-29 21:41:43,280 INFO sqlalchemy.engine.base.Engine {}
2016-11-29 21:41:43,281 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-11-29 21:41:43,282 INFO sqlalchemy.engine.base.Engine INSERT INTO users (name, fullname, password) VALUES (%(name)s, %(fullname)s, %(password)s)
2016-11-29 21:41:43,282 INFO sqlalchemy.engine.base.Engine {'password': '123456', 'fullname': 'CC Liu', 'name': 'liu'}
2016-11-29 21:41:43,283 INFO sqlalchemy.engine.base.Engine INSERT INTO users (name, fullname, password) VALUES (%(name)s, %(fullname)s, %(password)s)
2016-11-29 21:41:43,283 INFO sqlalchemy.engine.base.Engine {'password': '123456', 'fullname': 'Liu cc', 'name': 'laven'}
2016-11-29 21:41:43,284 INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (address, user_id, admin_id) VALUES (%(address)s, %(user_id)s, %(admin_id)s)
2016-11-29 21:41:43,284 INFO sqlalchemy.engine.base.Engine {'user_id': 1, 'admin_id': 2, 'address': 'liu@laven.cn'}
2016-11-29 21:41:43,285 INFO sqlalchemy.engine.base.Engine INSERT INTO addresses (address, user_id, admin_id) VALUES (%(address)s, %(user_id)s, %(admin_id)s)
2016-11-29 21:41:43,285 INFO sqlalchemy.engine.base.Engine {'user_id': 1, 'admin_id': 2, 'address': 'lcc@163.com'}
2016-11-29 21:41:43,286 INFO sqlalchemy.engine.base.Engine COMMIT
 #+END_SRC

接下来在数据库中查询已插入的数据，
 #+BEGIN_SRC sql
mysql> select * from users;
+----+-------+----------+----------+
| id | name  | fullname | password |
+----+-------+----------+----------+
|  1 | liu   | CC Liu   | 123456   |
|  2 | laven | Liu cc   | 123456   |
+----+-------+----------+----------+
2 rows in set (0.00 sec)

mysql> select * from addresses;
+----+--------------+---------+----------+
| id | address      | user_id | admin_id |
+----+--------------+---------+----------+
|  1 | liu@laven.cn |       1 |        2 |
|  2 | lcc@163.com  |       1 |        2 |
+----+--------------+---------+----------+
2 rows in set (0.00 sec)

mysql> select users.* from users join addresses as a1 on users.id = a1.user_id join addresses as a2 on users.id = a2.user_id where a1.address = 'lcc@163.com' and a2.admin_id = 2;
+----+------+----------+----------+
| id | name | fullname | password |
+----+------+----------+----------+
|  1 | liu  | CC Liu   | 123456   |
|  1 | liu  | CC Liu   | 123456   |
+----+------+----------+----------+
2 rows in set (0.00 sec)
 #+END_SRC

对同一张表有多个外键的时候，需要foreign_keys参数。
** SQLAchemy子查询
 #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 13-orm]$ cat sqlalchemy_sub_query.py
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.sql import func
from sqlalchemy.ext.declarative import declarative_base


Model = declarative_base()
Session = sessionmaker()


class User(Model):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  name = Column(String(45), unique=True, nullable=False)
  fullname = Column(String(128), index=True, nullable=True)
  password = Column(String(128), nullable=False)

  addresses = relationship('Address', back_populates='user', foreign_keys="[Address.user_id]")
  managed_addresses = relationship('Address', back_populates='admin', foreign_keys="[Address.admin_id]")

  def __repr__(self):
	  return 'User<id={},name={},fullname={}>'.format(self.id,
													  self.name,
													  self.fullname)


class Address(Model):
  __tablename__ = 'addresses'

  id = Column(Integer, primary_key=True, autoincrement=True)
  address = Column(String(128), unique=True, nullable=False)
  user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
  admin_id = Column(Integer, ForeignKey('users.id'), nullable=False)

  user = relationship('User', back_populates='addresses', foreign_keys=[user_id])
  admin = relationship('User', back_populates='managed_addresses', foreign_keys=[admin_id])

  def __repr__(self):
	  return 'Address<id={},address={}>'.format(self.id, self.address)

if __name__ == '__main__':
  engine = create_engine('mysql+pymysql://root:helin123456@127.0.0.1:3306/demo', echo=True)    
  Session.configure(bind=engine)
  session = Session()

  # Model.metadata.drop_all(engine)
  # Model.metadata.create_all(engine)

  # select users.*, c.count from users join (
  #     select user_id, count(*) as count from addresses group by user_id
  # ) as counter on users.id = counter.user_id

  stmt = session.query(Address.user_id, func.count('*').label('count')).group_by(Address.user_id).subquery()
  result = session.query(User, stmt.c.count).join(stmt, User.id == stmt.c.user_id).all()
  print(result)
 #+END_SRC

执行结果为：
 #+BEGIN_SRC sh
[lavenliu@VM_113_230_centos 13-orm]$ python sqlalchemy_sub_query.py
2016-12-01 21:22:14,667 INFO sqlalchemy.engine.base.Engine SHOW VARIABLES LIKE 'sql_mode'
2016-12-01 21:22:14,667 INFO sqlalchemy.engine.base.Engine {}
2016-12-01 21:22:14,668 INFO sqlalchemy.engine.base.Engine SELECT DATABASE()
2016-12-01 21:22:14,668 INFO sqlalchemy.engine.base.Engine {}
2016-12-01 21:22:14,669 INFO sqlalchemy.engine.base.Engine show collation where `Charset` = 'utf8' and `Collation` = 'utf8_bin'
2016-12-01 21:22:14,669 INFO sqlalchemy.engine.base.Engine {}
2016-12-01 21:22:14,671 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS CHAR(60)) AS anon_1
2016-12-01 21:22:14,671 INFO sqlalchemy.engine.base.Engine {}
2016-12-01 21:22:14,672 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS CHAR(60)) AS anon_1
2016-12-01 21:22:14,672 INFO sqlalchemy.engine.base.Engine {}
2016-12-01 21:22:14,672 INFO sqlalchemy.engine.base.Engine SELECT CAST('test collated returns' AS CHAR CHARACTER SET utf8) COLLATE utf8_bin AS anon_1
2016-12-01 21:22:14,673 INFO sqlalchemy.engine.base.Engine {}
2016-12-01 21:22:14,674 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-12-01 21:22:14,675 INFO sqlalchemy.engine.base.Engine SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password, anon_1.count AS anon_1_count 
FROM users INNER JOIN (SELECT addresses.user_id AS user_id, count(%(count_1)s) AS count 
FROM addresses GROUP BY addresses.user_id) AS anon_1 ON users.id = anon_1.user_id
2016-12-01 21:22:14,675 INFO sqlalchemy.engine.base.Engine {'count_1': '*'}
[(User<id=1,name=liu,fullname=CC Liu>, 2)]
 #+END_SRC

存在关系的时候，数据是按需加载的。
** SQLAchemy之多对多关系
* 常用模块
** lru_cache
lru_cache的maxsize默认是128，如果为None，则表示不做任何限制。
#+BEGIN_SRC python :results output :exports both
import time
import datetime
import functools


def logger(fn):
	@functools.wraps(fn)
	def wrap(*args, **kwargs):
		start = datetime.datetime.now()
		ret = fn(*args, **kwargs)
		end = datetime.datetime.now()
		print('call {} took {}'.format(fn.__name__, end - start))
		return ret
	return wrap


@logger
@functools.lru_cache(3)
def sleep(x):
	time.sleep(x)
	return x

sleep(3)
print('--------------------')
sleep(3)
print('')
sleep(4)
print('--------------------')
sleep(4)
print('')
sleep(2)
print('--------------------')
sleep(2)
print('')
sleep(1)
print('--------------------')
sleep(1)
print('')
sleep(5)
print('--------------------')
sleep(5)
print('')
sleep(3)
print('--------------------')
sleep(3)

#+END_SRC

#+RESULTS:
#+begin_example
call sleep took 0:00:03.005144
--------------------
call sleep took 0:00:00.000007

call sleep took 0:00:04.005131
--------------------
call sleep took 0:00:00.000007

call sleep took 0:00:02.002709
--------------------
call sleep took 0:00:00.000007

call sleep took 0:00:01.004751
--------------------
call sleep took 0:00:00.000014

call sleep took 0:00:05.005150
--------------------
call sleep took 0:00:00.000012

call sleep took 0:00:03.005129
--------------------
call sleep took 0:00:00.000006
#+end_example

* 第三方模块
** pysnmp
一个配置文件，
 #+BEGIN_SRC python :results output :exports both
[root@drbdnode2 ~]# cat snmp-manager.cfg 
[system_1]
description=My Server
address=192.168.1.182
port=161
communityro=public

[check_1]
description=LAN incoming traffic
oid=1.3.6.1.2.1.2.2.1.10.4
system=system_1

[check_2]
description=LAN incoming traffic
oid=1.3.6.1.2.1.2.2.1.10.2
system=system_1
 #+END_SRC

代码，
 #+BEGIN_SRC python :results output :exports both
[root@drbdnode2 ~]# cat snmp-manager.py 
import sys
from ConfigParser import SafeConfigParser
from pysnmp.entity.rfc3413.oneliner import cmdgen


class SnmpManager:
  def __init__(self):
	  self.systems = {}

  def add_system(self, id, descr, addr, port, comm_ro):
	  self.systems[id] = {'description' : descr,
						  'address'     : addr,
						  'port'        : int(port),
						  'communityro' : comm_ro,
						  'checks'      : {}}

  def add_check(self, id, oid, descr, system):
	  oid_tuple = tuple([int(i) for i in oid.split('.')])
	  self.systems[system]['checks'][id] = {'description': descr,
											'oid'        : oid_tuple, }

  def query_all_systems(self):
	  cg = cmdgen.CommandGenerator()
	  for system in self.systems.values():
		  comm_data = cmdgen.CommunityData('my-manager', system['communityro'])
		  transport = cmdgen.UdpTransportTarget((system['address'], system['port']))
		  for check in system['checks'].values():
			  oid = check['oid']
			  errInd, errStatus, errIdx, result = cg.getCmd(comm_data, transport, oid)
			  if not errInd and not errStatus:
				  print "%s/%s -> %s" % (system['description'],
										 check['description'],
										 str(result[0][1]))

def main(conf_file=""):
  if not conf_file:
	  sys.exit(-1)
  config = SafeConfigParser()
  config.read(conf_file)
  snmp_manager = SnmpManager()
  for system in [s for s in config.sections() if s.startswith('system')]:
	  snmp_manager.add_system(system,
							  config.get(system, 'description'),
							  config.get(system, 'address'),
							  config.get(system, 'port'),
							  config.get(system, 'communityro'))
  for check in [c for c in config.sections() if c.startswith('check')]:
	  snmp_manager.add_check(check,
							 config.get(check, 'oid'),
							 config.get(check, 'description'),
							 config.get(check, 'system'))

  snmp_manager.query_all_systems()


if __name__ == '__main__':
  main(conf_file='snmp-manager.cfg')

 #+END_SRC
* 项目实战
** 日志分析
*** 需求分析
日志分析的流程：开始、读入、解析、分析、展示、结束

使用到的Python库为pygal。
#+BEGIN_SRC sh
pip install pygal
#+END_SRC

还用到了re，match是从头匹配，search是全文搜索的。

日志文件的字段：
#+BEGIN_SRC python
IP
时间
方法
URL
版本
状态
长度
referer
UA
#+END_SRC

可以分析到：
1. 流量分析     sum        line chart
2. TOP 10 URL   count      bar chart
3. TOP 10 IP    count      bar chart
4. TOP 10 UA    count      bar chart
5. 状态的分布   group by   pie chart stack chart
6. UA的分布     group by   pie chart stack chart
7. 版本的分布   group by   pie chart stack chart

正则表达式：
#+BEGIN_SRC python :result output
import re
o = re.compile(r'a')
o.match('aaaa')
# : <_sre.SRE_Match object; span=(0, 1), match='a'>
o.match('baba') # 从字符串的开头处匹配
# match不到就返回None
match(string=None, pos=0, endpos=9223372036854775807, *, pattern=None) method of _sre.SRE_Pattern instance
  Matches zero or more characters at the beginning of the string.
#+END_SRC

search:
#+BEGIN_SRC python :result output
import re
xxx = re.compile(r'a')
#xxx.match('aaa') #   : <_sre.SRE_Match object; span=(1, 2), match='a'>
xxx.match('baba')
xxx.search('baba') #   : <_sre.SRE_Match object; span=(1, 2), match='a'>
#+END_SRC

以上的两个例子说明：match是从头匹配；search是全文搜索的。

如果要捕获的话，使用小括号：
#+BEGIN_SRC python
import re

o = re.compile('(test)')
m = o.search('this is a test string')
m.group()
m.groups()
#+END_SRC

还支持命名捕获，语法如下：
#+BEGIN_SRC python
(?P<name>)
# 举个例子
o = re.compile(r'(?P<name>\d+)')
m = o.search('127.0.0.1')
m.groups()
m.groupdict()
#+END_SRC

使用re来处理一条日志信息，
#+BEGIN_SRC python :result output
import re
import pprint


line = '66.249.69.131 - - [10/Aug/2016:03:20:09 +0800] "GET /robots.txt HTTP/1.1" 404 162 "-" "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"'

p = r'(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) .* .* \[(?P<time>.*)\] "(?P<method>\w+) (?P<url>[^\s]*) (?P<version>[\w|/\.\d]*)" (?P<status>\d{3}) (?P<length>\d+) "(?P<referer>[^\s]*)" "(?P<ua>.*)"'
o = re.compile(p)
m = o.search(line)
if m:
  print(m.groupdict())
{'ip': '66.249.69.131'}

if m:
  pprint.pprint(m.groupdict(), indent=4)
{   'ip': '66.249.69.131',
  'length': '162',
  'method': 'GET',
  'referer': '-',
  'status': '404',
  'time': '10/Aug/2016:03:20:09 +0800',
  'ua': 'Mozilla/5.0 (compatible; Googlebot/2.1; '
		'+http://www.google.com/bot.html)',
  'url': '/robots.txt',
  'version': 'HTTP/1.1'}
#+END_SRC

测试一下access.log文件有多少行匹配：
#+BEGIN_SRC python
with open('access.log') as f:
  total = 0
  matched = 0
  for line in f:
		  total += 1
		  if o.search(line):
				  matched += 1
		  else:
			  print(line, )
  print(total)
  print(matched)

83.149.37.131 - - [10/Aug/2016:09:22:05 +0800] "Lp" 400 166 "-" "-"
83.149.37.131 - - [10/Aug/2016:09:29:06 +0800] "Lp" 400 166 "-" "-"
180.98.17.34 - - [10/Aug/2016:10:44:19 +0800] "GET /6471001\xE4\xB8\x80\xE6\xAD\xA5\xE5\x88\xB0\xE4\xBD\x8D\xE5\xAE\x9E\xE7\x8E\xB0zabbix\xE5\xAE\x89\xE8\xA3\x85 \xE2\x80\x93 linux\xE8\xBF\x90\xE7\xBB\xB4\xE9\x83\xA8\xE8\x90\xBD HTTP/1.1" 404 6208 "-" "Mozilla/5.0 (Linux; U; Android 6.0.1; zh-cn; MI 4C Build/MMB29M) AppleWebKit/533.1 (KHTML, like Gecko) Mobile Safari/533.1"
180.98.17.34 - - [10/Aug/2016:10:44:19 +0800] "GET /6471001\xE4\xB8\x80\xE6\xAD\xA5\xE5\x88\xB0\xE4\xBD\x8D\xE5\xAE\x9E\xE7\x8E\xB0zabbix\xE5\xAE\x89\xE8\xA3\x85 \xE2\x80\x93 linux\xE8\xBF\x90\xE7\xBB\xB4\xE9\x83\xA8\xE8\x90\xBD HTTP/1.1" 404 6208 "-" "Mozilla/5.0 (Linux; U; Android 6.0.1; zh-cn; MI 4C Build/MMB29M) AppleWebKit/533.1 (KHTML, like Gecko) Mobile Safari/533.1"
180.98.17.34 - - [10/Aug/2016:10:44:20 +0800] "GET /6471001\xE4\xB8\x80\xE6\xAD\xA5\xE5\x88\xB0\xE4\xBD\x8D\xE5\xAE\x9E\xE7\x8E\xB0zabbix\xE5\xAE\x89\xE8\xA3\x85 \xE2\x80\x93 linux\xE8\xBF\x90\xE7\xBB\xB4\xE9\x83\xA8\xE8\x90\xBD HTTP/1.1" 404 6208 "-" "Mozilla/5.0 (Linux; U; Android 6.0.1; zh-cn; MI 4C Build/MMB29M) AppleWebKit/533.1 (KHTML, like Gecko) Mobile Safari/533.1"
180.98.17.34 - - [10/Aug/2016:10:44:20 +0800] "GET /6471001\xE4\xB8\x80\xE6\xAD\xA5\xE5\x88\xB0\xE4\xBD\x8D\xE5\xAE\x9E\xE7\x8E\xB0zabbix\xE5\xAE\x89\xE8\xA3\x85 \xE2\x80\x93 linux\xE8\xBF\x90\xE7\xBB\xB4\xE9\x83\xA8\xE8\x90\xBD HTTP/1.1" 404 6208 "-" "Mozilla/5.0 (Linux; U; Android 6.0.1; zh-cn; MI 4C Build/MMB29M) AppleWebKit/533.1 (KHTML, like Gecko) Mobile Safari/533.1"
169.229.3.91 - - [10/Aug/2016:21:45:06 +0800] "\xC5\xFCQ8:\x03\xAE\xC7\xF9\xA3p\x8A5\xF0\xA3\x80X\xC1\x871\x9F\x98`\x8D\x8B8\xA6\x81Ch\x18\x03,)\xF3_\xD0-\xA8\xC0\xF3t3\xA4M\xD5e\xA1\xB9\xE6e\xC6\xD8\xADN\xFC<\xE4{\xCA\xB4\xDE\xC1\xF2" 400 166 "-" "-"

92264
92257
# 只有7行不匹配，说明我们的正则匹配是没有问题的
#+END_SRC

关于时间戳的解析：
#+BEGIN_SRC python
import datetime

s = '10/Aug/2016:03:20:09 +0800'
fmt = '%d/%b/%Y:%H:%M:%S %z'
dt = datetime.datetime.strptime(s, fmt)
dt
dt.strftime('%Y%m%d%H%M')
#+END_SRC

如何处理不是每分钟都有数据的点的情况？
#+BEGIN_SRC python
import datetime

now = datetime.datetime.now()
end = now + datetime.timedelta(hours=1)
now
end
cur = now
while cur < end:
  print(cur.strftime('%Y%m%d%H%M'))
  cur = cur + datetime.timedelta(minutes=1)

201610231017
201610231018
201610231019
201610231020
...
201610231116
# 提前填充出ret
#+END_SRC
*** 流量分析
pygal的使用：
  #+BEGIN_SRC python
import pygal
import math

line_chart = pygal.Line()
line_chart.title = 'Test Chart'
line_chart.x_labels = [str(x) for x in range(0, 360, 30)]
line_chart.add('sin', [math.sin(x) for x in range(0, 360, 30)])
  #+END_SRC

流量分析最终的代码为：
  #+BEGIN_SRC python
cat analysis.py
# coding: utf-8

import re
import sys
import pygal
import datetime


def read_log(path):
  with open(path) as f:
	  yield from f
	  # yield from f等价于如下两行
	  # for line in f:
	  #     yield line


def parse(path):
  o = re.compile(r'(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) .* .* \[(?P<time>.*)\] "(?P<method>\w+) (?P<url>[^\s]*) (?P<version>[\w|/\.\d]*)" (?P<status>\d{3}) (?P<length>\d+) "(?P<referer>[^\s]*)" "(?P<ua>.*)"')
  for line in read_log(path):
	  m = o.search(line.rstrip('\n'))
	  if m:
		  data = m.groupdict()
		  data['time'] = datetime.datetime.strptime(data['time'], '%d/%b/%Y:%H:%M:%S %z')
		  yield data


def window(time):
  pass


def count(key, data):
  if key not in data.keys():
	  data[key] = 0
  data[key] += 1
  return data


def analysis(path):
  ret = {}
  # start = datetime.datetime(2016, 8, 10, 3, 20)
  # end = datetime.datetime(2016, 8, 11, 3, 20)

  def init_data():
	  return {
		  'ip': {},
		  'url': {},
		  'ua': {},
		  'status': {},
		  'throughput': 0
	  }
  for item in parse(path):
	  time = item['time'].strftime('%Y%m%d%H%M')
	  if time not in ret.keys():
		  ret[time] = init_data()
	  data = ret[time]
	  for key, value in data.items():
		  if key != 'throughput':
			  data[key] = count(item[key], value)
	  data['throughput'] += int(item['length'])
  return ret


def render_line(name, labels, data):
  line = pygal.Line()
  line.title = name
  line.x_labels = labels
  line.add(name, data)
  return line.render()


def render_bar(name, data):
  pass


def render_pie(name, data):
  pass


def main():
  data = analysis(sys.argv[1])
  rs = list(data.items())
  rs.sort(key=lambda x: x[0])
  labels = [x[0] for x in rs]
  throughput = [x[1]['throughput'] for x in rs]
  svg = render_line('throughput', labels=labels, data=throughput)
  with open('throughput.svg', 'wb') as f:
	  f.write(svg)

if __name__ == '__main__':
  main()
  #+END_SRC

在命令行里执行：
  #+BEGIN_SRC python
python analysis.py access.log
  #+END_SRC
*** 流式分析
influxdb，时序数据库；每条数据都带有时间戳；查询的时候也肯定是时间相关的。

典型的时序数据有log、metric、股价、汇率。

influxdb专门为metric实现的数据库。可以用来分析流量、QPS、错误率等。

ds.py用来制造数据源：
#+BEGIN_SRC python

#+END_SRC

验证ds.py代码是否可用：
  #+BEGIN_SRC sh
python ds.py access.log generated.log
# ds只是模拟apache或nginx来产生日志数据而已
  #+END_SRC
检查一下generated.log的数据是否正确：
  #+BEGIN_SRC python
p = r'(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) .* .* \[(?P<time>.*)\] "(?P<method>\w+) (?P<url>[^\s]*) (?P<version>[\w|/\.\d]*)" (?P<status>\d{3}) (?P<length>\d+) "(?P<referer>[^\s]*)" "(?P<ua>.*)"'
o = re.compile(p)

with open('generated.log') as f:
  total = 0
  matched = 0
  for line in f:
	  total += 1
	  if o.search(line):
		  matched += 1
	  else:
		  print(line, )
	  print(total)
	  print(matched)
  #+END_SRC

日志数据有了，接下来处理这些日志：
  #+BEGIN_SRC python
# analysis2.py
import threading


  #+END_SRC

聚合流量、count、错误率 
*** 同时处理多个文件
线程之间的通信，使用queue。put与get方法。
*** 多进程parse
I/O的时候会有阻塞。I/O的时候，大多数时间是花在等待上的。当等待的时候，
线程会进入睡眠态。

多线程的时候，在一个Python解释器里。多进程的时候，每个进程会启动一
个解释器。这样就跨解释器了，多进程间通信就要用
multiprocessing.Queue了。queue.Queue是线程安全，但非进程安全；
multiprocessing.Queue是进程安全的；queue.Queue不需要序列化；
multiprocessing.Queue会序列化。
  #+BEGIN_SRC python
cat mult_process.py
import random
import logging
import multiprocessing

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s [%(processName)s] - %(message)s')


def producer(q):
  while True:
	  ret = random.randint(0, 100)
	  logging.info('product {}'.format(ret))
	  q.put(ret)


def consumer(q):
  while True:
	  logging.info('consume {}'.format(q.get()))

q = multiprocessing.Queue()

p = multiprocessing.Process(target=producer, name='producer', args=(q, ))
c = multiprocessing.Process(target=consumer, name='consumer', args=(q, ))
p.start()
c.start()

p.join()
c.join()
  #+END_SRC
*** 多进程agg
** 日志分析 - 20170211
*** 需求分析
1. 读入（非结构化数据）
2. 提取有用信息，组成结构化数据
3. 分析
4. 保存结果

提取数据的代码：
#+BEGIN_SRC python :results output :exports both
line = '61.135.169.9 - - [10/Aug/2016:04:12:38 +0800] "GET /ueditor/php/upload/image/20160808/1470637584812198.png HTTP/1.1" 200 13317 "-" "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)"'


def extract(line):
	names = ('remote', '', '', 'time', 'request', 'status', 'length', '', 'ua')
	tmp = []
	ret = []
	split = True

	# 比正则表达式速度要快
	for c in line:
		if c == '[':
			split = False
			continue
		if c == ']':
			split = True
			continue
		if c == '"':
			split = not split
			continue
		if c == ' ' and split:
			ret.append(''.join(tmp))
			tmp.clear()
		else:
			tmp.append(c)
	ret.append(''.join(tmp))
	# 结果组合
	result = dict(zip(names, ret))
	# 删除空的
	result.pop('', None)
	return result


print(extract(line))
#+END_SRC

#+RESULTS:
: {
:    'time': '10/Aug/2016:04:12:38 +0800', 
:    'ua': 'Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)', 
:    'remote': '61.135.169.9', 
:    'status': '200', 
:    'length': '13317', 
:    'request': 'GET /ueditor/php/upload/image/20160808/1470637584812198.png HTTP/1.1'
: }

针对上述的结果进行一些转换，如time要转换为datetime格式，status要转
换为数字等。
#+BEGIN_SRC python :results output :exports both
import datetime
from collections import namedtuple

Request = namedtuple('Request', ['method', 'url', 'version'])

def request(src: str) -> Request:
	return Request(*src.split())

print(request('GET /robots.txt HTTP/1.1'))
#+END_SRC

#+RESULTS:
: Request(method='GET', url='/robots.txt', version='HTTP/1.1')

继续写转换：
#+BEGIN_SRC python :results output :exports both
import datetime
from collections import namedtuple

Request = namedtuple('Request', ['method', 'url', 'version'])
MapItem = namedtuple('MapItem', ['name', 'convert'])

mapping = [
	MapItem('remote', lambda x: x),
	MapItem('', None),
	MapItem('', None),
	MapItem('time', lambda x: datetime.datetime.strptime(x, '%d/%b/%Y:%H:%M:%S %z')),
	MapItem('request', lambda x: Request(*x.split())),
	MapItem('status', int),
	MapItem('length', int),
	MapItem('', None),
	MapItem('ua', lambda x: x)
]
#+END_SRC

extract函数的代码为：
#+BEGIN_SRC python :results output :exports both
import datetime
from collections import namedtuple

line = '61.135.169.9 - - [10/Aug/2016:04:12:38 +0800] "GET /ueditor/php/upload/image/20160808/1470637584812198.png HTTP/1.1" 200 13317 "-" "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)"'

Request = namedtuple('Request', ['method', 'url', 'version'])
MapItem = namedtuple('MapItem', ['name', 'convert'])

mapping = [
	MapItem('remote', lambda x: x),
	MapItem('', None),
	MapItem('', None),
	MapItem('time', lambda x: datetime.datetime.strptime(x, '%d/%b/%Y:%H:%M:%S %z')),
	MapItem('request', lambda x: Request(*x.split())),
	MapItem('status', int),
	MapItem('length', int),
	MapItem('', None),
	MapItem('ua', lambda x: x)
]


def extract(line):
	tmp = []
	ret = []
	split = True

	# 比正则表达式速度要快
	for c in line:
		if c == '[':
			split = False
			continue
		if c == ']':
			split = True
			continue
		if c == '"':
			split = not split
			continue
		if c == ' ' and split:
			ret.append(''.join(tmp))
			tmp.clear()
		else:
			tmp.append(c)
	ret.append(''.join(tmp))
	# 结果组合
	result = dict()
	for i, item in enumerate(mapping):
		if item.name:
			result[item.name] = item.convert(ret[i])
	return result

print(extract(line))
#+END_SRC

#+RESULTS:
: {'request': Request(method='GET', url='/ueditor/php/upload/image/20160808/1470637584812198.png', version='HTTP/1.1'), 'status': 200, 'time': datetime.datetime(2016, 8, 10, 4, 12, 38, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))), 'ua': 'Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)', 'remote': '61.135.169.9', 'length': 13317}

使用正则的方式解析：
#+BEGIN_SRC python :results output :exports both
import re
import datetime

mapping = {
	'length': int,
	'request': lambda x: Request(*x.split()),
	'status': int,
	'time': lambda x: datetime.datetime.strptime(x, '%d/%b/%Y:%H:%M:%S %z')
}

line = '66.249.69.44 - - [11/Aug/2016:04:31:25 +0800] "GET /18051 HTTP/1.1" 200 13551 "-" "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"'
regex = r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) - - \[(.*)\] "(.*)" (\d+) (\d+) ".*" "(.*)"'
m = re.match(regex, line)
print(m.groups())
#+END_SRC

#+RESULTS:
: ('66.249.69.44', '11/Aug/2016:04:31:25 +0800', 'GET /18051 HTTP/1.1', '200', '13551', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)')

使用命名捕获，
#+BEGIN_SRC python :results output :exports both
# (?P<name>) 命名捕获
import re
import datetime
from collections import namedtuple

Request = namedtuple('Request', ['method', 'url', 'version'])
line = '66.249.69.44 - - [11/Aug/2016:04:31:25 +0800] "GET /18051 HTTP/1.1" 200 13551 "-" "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"'
regex = r'(?P<remote>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) - - \[(?P<time>.*)\] "(?P<request>.*)" (?P<status>\d+) (?P<length>\d+) ".*" "(?P<ua>.*)"'
# pattern编译之后，速度有提升 (AST)
matcher = re.compile(regex)

mapping = {
	'length': int,
	'request': lambda x: Request(*x.split()),
	'status': int,
	'time': lambda x: datetime.datetime.strptime(x, '%d/%b/%Y:%H:%M:%S %z')
}


def extract(line):
	m = matcher.match(line)
	if m:
		ret = m.groupdict()
		return {k:mapping.get(k, lambda x: x)(v) for k, v in ret.items()}
	raise Exception(line)

print(extract(line))
#+END_SRC

#+RESULTS:
: {'length': 13551, 
:  'ua': 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 
:  'request': Request(method='GET', url='/18051', version='HTTP/1.1'), 
:  'remote': '66.249.69.44', 
:  'time': datetime.datetime(2016, 8, 11, 4, 31, 25, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))), 
:  'status': 200}

数据提取功能完成后，接下来 *载入数据*,
#+BEGIN_SRC python :results output :exports both
def load(path):
	with open(path) as f:
		try:
			yield extract(f.readline())
		except:
			pass
#+END_SRC
*** 数据分析
时序数据，滑动窗口。

实现一个滑动窗口的函数。
#+BEGIN_SRC python :results output :exports both
import queue
from collections import namedtuple

Handler = namedtuple('Handler', ['handle', 'notify'])


def window(source, handler, interval: int, width: int):
	# source: 是一个queue，用于产生数据
	# handler: 是一个函数，用于处理数据
	# notify: 是一个函数，用于当窗口滑动的时候，通知handle
	# interval: 多久滑动一次
	# width: 窗口宽度
	store = []
	start = datetime.datetime.now()
	while True:
		data = next(source)
		current = datetime.datetime
#+END_SRC
*** 流式读取
#+BEGIN_SRC python :results output :exports both
import time

def load(path):
	with open(path) as f:
		while True:
			for line in f:
				try:
					yield extract(line)
				except:
					pass
		time.sleep(0.1)
#+END_SRC

接下来写代码生成日志文件，
#+BEGIN_SRC python :results output :exports both
import sys
import time

# loggen.py

with open(sys.argv[1]) as r:
	with open(sys.argv[2], 'w') as w:
		for line in r:
			w.write(line)
			w.flush()
			time.sleep(1)
#+END_SRC

如何使用，
  #+BEGIN_SRC sh
python loggen.py access.log a.log
  #+END_SRC

#+BEGIN_SRC python :results output :exports both
for item in load('a.log'):
	print(item['time'])
#+END_SRC

实现tailf功能的两种方式：
1. long polling
2. inotify
** 多人博客
 1. 用户相关的
	#+BEGIN_SRC sh
/login           # 登录
/register        # 注册
/post/{username} # 文章列表
	#+END_SRC
 2. 文章相关的
	#+BEGIN_SRC sh
/posts      # 列表
/posts/{id} # 内容
/post       # 编辑
## 文章的属性
# 点赞
# 阅读量
	#+END_SRC

从前往后的设计。

https://coding.net/u/comyn/p/blog/git
*** 多人博客数据库设计
  1. user表
	 #+BEGIN_SRC sql
id        BIGINT not null primary key
nickname  not null unicode varchar(45)
mail      not null unicode varchar(45)
password  not null varchar(45)
	 #+END_SRC
  2. post表
	 #+BEGIN_SRC sql
id        BIGINT not null primary key
title     not null varchar(128)
author    not null 
	 #+END_SRC
*** model设计
*** 注册与登录
*** 认证和文章相关接口
*** 其他接口实现
*** 前端
** CMDB
*** CMDB需求收集
*** CMDB表结构设计与schema变更
*** schema变更历史
*** entity增删改
*** entity历史记录
*** 关系与关系如何影响entity的增删改
*** 关系的增删改
*** 实例
*** Model层
*** schema增加字段
*** field删除和修改
** 任务调度系统
任务调度系统能做什么：
1. 远程执行命令
 + 有agent  -- 自己实现agent
   + agent需要实现什么基本功能：
	 - 执行命令
	 - 通信协议
 + 无agent  -- 使用已有的系统服务，如sshd，snmp，powershell，winrm，wmi
   + 优点：
   + 缺点：
*** 远程执行命令
有且只有一种方法执行系统命令，那就是subprocess模块，永远不要用
os.system与os.Popen模块执行系统命令。
 #+BEGIN_SRC python
import subprocess
proc = subprocess.Popen(['ls', '-l'])
# subprocess帮助文档
# 命令是以字符串列表的形式传入的
# 第0个参数是命令，之后的是命令的参数
# 有空格分开的，就要单独写出来
# 当shell=True的时候，会查找默认的shell，然后以-c的选项传递给默认的shell执行
#
## 打开shell与不打开shell的区别
# wiht Popen('test -e /tmp && echo ok', shell=True) :
#     pass
# with Popen(['test', '-e', '/tmp', '&&', 'echo', 'ok']):
#     pass
# with Popen(['/bin/bash', '-c', 'test -e /tmp && echo ok']):
#     pass
# bash -l -c "ls"
# -l 是以登录的方式执行，这样会加载/etc/profile及HOME下的.bash_profile
# echo "export TEST='123456'"
# with Popen(['/bin/bash', '-l', '-c', 'echo $TEST']):
#     pass
# 会输出123456
# with Popen('echo $TEST', shell=True):
#     pass
# 不会输出TEST环境变量
# 为什么以-l方式执行？agent通常是以守护进程的方式启动，修改的环境变量对它是不可见的。
# 当以登录shell执行的时候，limits.conf是能生效的。
 #+END_SRC

如何捕获输出及设置timeout。只需要设置stdout及stderr就可以了。
 #+BEGIN_SRC python
# 这里将标准错误输出也输出到标准输出了
with Popen(['/bin/bash', '-l', '-c', 'echo $TEST'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as p:
  p.wait()
  print(p.stdout.read())
with Popen(['/bin/bash', '-l', '-c', 'echo $TEST'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as p:
  p.wait() # 可以设置超时时间
  print(p.communicate())
 #+END_SRC
*** 架构设计
不管什么样的架构或什么样的协议，命令执行是不变的。接下来看如何进行
通讯协议的设计。

  #+BEGIN_EXAMPLE
master -> agent # agent以某种方式接收指令
# master向agent传递json格式
{
"command": "script",
"timeout": 100,
"targets": [],
"parallel": 1,
"failure": 0,
"callback": ""
}

{
"code": 0,
"output": ""
}

agent的结果怎么返回？输出结果要么按原路返回； # 优点：只需要建立一个链接就可以了；缺点：
还有就是master监听一个端口，用来接收agent的返回结果。
  #+END_EXAMPLE

push与pull的区别。返回结果是push方式是更优的。agent串行执行还是并
行执行？要看任务之间是否有依赖，如果任务之间没有依赖关系，并行更优。

agent执行任务时，通常使用串行执行，如果并行执行的话，则会出现如下
问题：
1. 任务之间可能相互干扰
2. 任务编排

简单可依赖，agent使用串行的方式。如果agent采用串行，执行采用pull的
方式从master端获取则更优。agent对master要保持一个长链接。保持长链
接的一个挑战是心跳和重连。

如果agent正在执行任务却宕掉了，怎么办？master端保持agent端的当前任
务，直到有返回结果才确认agent执行成功。

master如何保持队列？需要引入一个靠谱的第三方来保持任务。

  #+BEGIN_EXAMPLE
global_task_queue # 整个平台一个

local_task_queue  # 每个agent一个

1. 用户发起请求
2. master put global_task_queue
3. 根据并行度参数，复制到合适的local_task_queue
4. 当agent询问任务的时候，只需要看它对应的local_task_queue有无任务就行了
4. master调度 # 如何调度
  #+END_EXAMPLE

整体架构拓扑图。
*** 调度过程
调度过程流程图

  #+BEGIN_EXAMPLE
t      target总数
p      并行度
f      失败数
s      成功数
r      正在执行的数量
rate   最大允许失败率

# 判断失败率
if f / t > rate:
  set task failed
if (f+s) == t:
  set task success
if r < p:
  schedule(p-r)
  #+END_EXAMPLE
*** ZooKeeper节点设计
使用Zookeeper作为任务队列，任务队列的要求：
1. 持久化
2. 高可用
3. 全局队列是可修改的

ZooKeeper是一个分布式协调软件。

ZooKeeper相关术语：
  #+BEGIN_EXAMPLE
1. 节点   -- 目录/文件  # 可以进行增删改查
2. watch  -- 类似inotify的概念，当节点有修改的时候，可以通知watcher

ZooKeeper是高可用的，强一致性的。

一致性分为：
1. 强一致性   # 在所有节点上写入要么成功，要么失败；并且在所有节点上同时可见
2. 弱一致性   # 有可能存在中间状态。不保证所有节点都写入成功。
3. 最终一致性 # 在一个节点上执行成功，最终会被同步到所有节点，但不是所有节点立刻可见。
  #+END_EXAMPLE

ZooKeeper节点数：1 3 5

heartbeat信息：
基础监控信息，当前正在执行的任务，当前时间、agent版本，当前正在执
行的任务。

如何通知用户？用户并不知道执行情况。

通知完毕用户之后，删除task。

callback做一些清除的工作。任务信息持久化，审计等。

一点点缺陷，用户看不到输出。如果任务成功了，皆大欢喜；如果任务失败
了，就傻眼了。

如何让用户看到实时输出？先如何看到输出，然后看到实时输出。

一个截图。
*** 跨机房实现
一个截图

Job的版本化管理。

如何实时的看输出。
*** ZooKeeper基本操作
CURD，watch

kazoo库，其api比较人性化，纯Python的。
  #+BEGIN_SRC sh
pip install kazoo
  #+END_SRC

一个简单的操作ZK的脚本：
  #+BEGIN_SRC python
[lavenliu@VM_113_230_centos 18-msched]$ cat zk.py 
import logging
import threading
from kazoo.client import KazooClient
from kazoo.recipe.watchers import DataWatch, ChildrenWatch

logging.basicConfig(level=logging.INFO)

# connection
client = KazooClient(hosts='192.168.xxx.yyy:2181')
client.start()


# create nodes
client.create('/test')
client.create('/test/t1', value=b'123456')
# ensure_path can cursive create
# create method can not cursive create
client.ensure_path('/test/t2')
client.ensure_path('/test/t3/t4')
# # shell ops
# ls /test
# get /test
# get /test/t1

# read method
ret = client.get('/test/t1')
print(ret)

data, stat = client.get('/test/t1')
print(data)
print(stat)

# exists
ret = client.exists('/test/t1')
print(ret)
ret = client.exists('/test/t6')
print(ret)

# get_children
ret = client.get_children('/test')
print(ret)

# write method
client.set('/test/t1', value=b'abcd')

# delete method
client.delete('/test/t2')
# it will throw exception if we delete a non-exists item
# delete recursive
client.delete('/test/t3', recursive=True)

# transaction support
# tx = client.transaction()
# tx.commit()


# watch method
# 由于不知道要传入什么参数
def watch_test(*args, **kwargs):
  print(args)
  print(kwargs)

# 接下来调用watch_test方法，打印其参数信息
# dw = DataWatch(client, '/test/t1', func=watch_test) # 执行完毕，脚步就退出了；因此，导入threading模块，让其阻塞

# 根据打印出来的参数信息，我们可以知道watch_test需要三个参数，
# data，stat，event

# 接下来重新定义watch_test方法
def watch(data, **kwargs):
  print(data)

dw = DataWatch(client, '/test/t1', func=watch) # 执行完毕，脚步就退出了；因此，导入threading模块，让其阻塞


def watch_children(*args, **kwargs):
  print(args)
  print(kwargs)


def watch_children_final(children):
  print(children)

# ChildrenWatch(client, '/test', func=watch_children)
ChildrenWatch(client, '/test', func=watch_children_final)
# 这时对ZK进行操作，查看脚本的输出结果
# DataWatch监听节点的信息变化
# ChildrenWatch监听节点的子节点的信息变化，子节点有更新监控不到

event = threading.Event()
try:
  event.wait()
except KeyboardInterrupt:
  event.set()
  #+END_SRC
*** agent实现
20170520

实现master与agent的通信。

#+BEGIN_SRC python :results output :exports both
# agent/msg.py
import os
import uuid
import ipaddress
import netifaces


class Messages:
	def __init__(self, path):
		if os.path.exists(path):
			with open(path) as f:
				self.id = f.readline()
		self.id = uuid.uuid4().hex
		with open(path, 'w') as f:
			f.write(self.id)

	def _get_addresses(self):
		addresses = []
		for iface in netifaces.interfaces():
			for nets in netifaces.ifaddresses(iface).values():
				for net in nets:
					addr = ipaddress.ip_address(net['addr'])
					if addr.is_loopback:
						continue
					if add.is_link_local:
						continue
					if addr.is_multicast:
						continue
					addresses.append(str(addr))
		return addresses

	def register(self):
		hostname = os.uname().nodename

		return {
			'type': 'register',
			'payload': {
				'id': self.id,
				'hostname', hostname,
				'ip': self._get_addresses()
			}
		}

	def heartbeat(self):
		return {
			'type': 'heartbeat',
			'payload': {
				'id': self.id,
				'hostname': os.uname.nodename,
			}
		}
#+END_SRC

#+BEGIN_SRC python :results output :exports both
# encoding: utf-8
# agent/cm.py

import socket
import threading
from .msg import Messages


class ConnectionManager:
	def __init__(self, master, message: Messages):
		self.master = master
		self.so = socket.socket()
		self.message = message

	def _encode(self, msg):
		return '{}\r\n'.format(msg).encode()

	def _heartbeat(self):
		while not self.event.is_set():
			self.so.send(self._encode(self.message.heartbeat()))
			self.event.wait(3)

	def _recv(self):
		f = self.so.makefile()
		while not self.event.is_set():
			msg = f.readline()
			# todo

	def start(self):
		"""在start的时候建立连接"""
		self.so.connect(self.master)
		self.so.send(self._encode(self.message.register()))
		threading.Thread(name='heartbeat', target=self._heartbeat, daemon=True)

	def shutdown(self):
		self.so.colse()
#+END_SRC
*** master实现
*** scheduler实现
*** callback实现
*** 20170520上课
1. 分发任务
2. 要能控制
 1. 控制并行
	同时只能有多少台机器执行
 2. 对错误需要做出响应
	最多允许失败的比率或者数量，当超出这一范围时，需要终止任务
 3. 对正在执行的任务，能终止其执行
3. 跨机房部署
4. 辅助的需求，对作业能做版本管理

当我们基于某个产品做二次开发，难度是非常大的。
1. 成本很高
要了解他整体架构，设计思想，熟悉大多数代码
2. 维护成本很高
通用化的目的， 你要加的功能， 也要具备通用化， 如果不是的话，就相当于维护了一个分支
3. 对参与者水平要求高
参与到社区，把你的代码反馈给社区

基于上述3点，不建议在现有产品上做二次开发。

m框架需要重新安装。

20170603日上课。
** 流程系统（20170603）
pipeline

有一系列的任务，这些任务是先后关系的，上一个任务的输出，可能是下一个任务的输入。

上线发布是一组任务。
1. 
2. 
3. 
4. 
5. 

为什么要实现这样的系统？为了更好的自动化，可以把任务编排起来，可以组织一类任务的执行。

事实上，可以认为要设计一个状态机，也可以称之为DAG（有向无环图）。DAG里，V就是一个任务，E指向下一个任务。

如：2个顶点，T1、T2，及一条边T1->T2，在执行T2任务之前需要执行T1。

如何用DAG表示pipeline。如果作为一个pipeline 除了需要时DAG之外， 还要满足什么条件？
DAG，必须要有一个开始节点（入度为0的点）。要有一个规范，必须有且只有一个开始节点。

如何判断结束？

如何顶一个DAG？2种方式，第一种，在线定义，把DAG存储到数据库里；第二种，使用代码定义，也就是说每个DAG
是一个Python模块。

定义pipeline的时候，是不是需要检测它是不是一个有向无环图？使用拓扑排序算法来检验。
1. 找到所有入度为0的点
2. 遍历为0的点，删除它的边
3. 重复第一步，直到无法继续，如果此时，图为空图，说明此图是有向无环图。
* 机器学习
** 概述
what，why，how

什么是机器学习？

为什么要机器学习？
1. 模式识别
2. 计算机视觉
3. 数据挖掘
4. 语音识别
5. 统计学习
6. 自然语言处理
** 计算机视觉
计算机视觉是机器学习的一个应用方向。是如何让机器去理解图像。包括对
图像里物体的识别，跟踪和测量。
* 深度学习
** 简单聊聊
Andrew Ng

UFLDL

Why：为什么讲？
很火，喜欢
为什么用python来学

What：什么是？
理解深度学习是什么
它能做什么

How：怎么讲？
从形象中演示理解原理
从实际应用中获得兴趣
*** 什么是人工智能
人工智能－》机器学习－》特征学习－》深度学习

最初的人工智能程序：
1. 基于规则的智能
2. 棋类等各种游戏
3. 基于输入输出映射规则的智能
* 每天一些练习题
** 写一个四则运算的解释器
** 写一个正则引擎
** 改进猜数字游戏。防作弊，错误输入判断
** 利用上次用户密码作业，请模拟注册过程
用户输入用户名后进行检测用户名是否在文件中的过程。并返回合理的错误
提示。如果不在则再输入密码，成功则增加用户信息到文件中，密码进行md5
加密处理。
** 增加用户名、密码的合法化判断和错误提示
用户名：字母、数字、下划线和横线的组合，且首字符应是字母，长度不小4

密码：字母，数字、下划线和横线的组合，且长度不小于6
** pgsql
 #+BEGIN_SRC python
__author__ = 'lavenliu'
import psycopg2

conn = psycopg2.connect(database='test',
					  user='postgres',
					  password='admin',
					  host='127.0.0.1',
					  port='5432')
cur = conn.cursor()
cur.execute('create table dept(id serial primary key, num integer, data varchar);')

cur.execute('insert into dept(num, data) values(%s, %s);', (1, 'aaa'))
cur.execute('insert into dept(num, data) values(%s, %s);', (2, 'bbb'))
cur.execute('insert into dept(num, data) values(%s, %s);', (3, 'ccc'))

cur.execute('select * from dept;')
rows = cur.fetchall()

for i in rows:
  print i # i是元组

conn.commit()
cur.close()
conn.close()
 #+END_SRC

参数传递应注意的：
 1. 所有的变量占位符都是%s
	#+BEGIN_SRC python
>>> cur.execute("INSERT INTO numbers VALUES (%d)", (42,)) # WRONG
>>> cur.execute("INSERT INTO numbers VALUES (%s)", (42,)) # correct
	#+END_SRC
 2. For positional variables binding, the second argument must
	always be a sequence, even if it contains a single variable. And
	remember that Python requires a comma to create a single element
	tuple:
	#+BEGIN_SRC python
>>> cur.execute("INSERT INTO foo VALUES (%s)", "bar")    # WRONG
>>> cur.execute("INSERT INTO foo VALUES (%s)", ("bar"))  # WRONG
>>> cur.execute("INSERT INTO foo VALUES (%s)", ("bar",)) # correct
>>> cur.execute("INSERT INTO foo VALUES (%s)", ["bar"])  # correct
	#+END_SRC
 3. Warning Never, never, NEVER use Python string concatenation (+)
	or string parameters interpolation (%) to pass variables to a
	SQL query string. Not even at gunpoint.
	#+BEGIN_SRC python
# the correct way to pass variables
>>> SQL = "INSERT INTO authors (name) VALUES (%s);" # Note: no quotes
>>> data = ("O'Reilly", )
>>> cur.execute(SQL, data) # Note: no % operator
	#+END_SRC
** 求100万以内的全部素数
1不是素数。除了1和其本身再没有别的除数可以被整除。
#+BEGIN_SRC python
x = 0
for x in range(2, 100000):
	for i in range(2, int(x ** 0.5)+1):
		if x % i == 0:
			break
	else:
		c += 1
print(c)
#+END_SRC
*** 使用更快的方法求100万以内的素数
1. 排除大于2的偶数，偶数肯定不是素数
2. 平方根

#+BEGIN_SRC python :results output code :exports both
ps = [2]

for i in range(3, 100):
	for x in ps:
		if i % x == 0:
			break
	else:
		ps.append(i)

print(ps)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
#+END_SRC
** 求一个任意整数的几何级数
什么是几何级数。算法描述：
#+BEGIN_EXAMPLE
a * q ^ 1 + a * q ^ 2 + ... + a * q ^ n
#+END_EXAMPLE

代码实现：
#+BEGIN_SRC python
a = 3
q = 2
n = 10

sum = 0

#+END_SRC
** 求菲波那切数列的第101项
算法描述：
#+BEGIN_EXAMPLE
fib(n) == 1 if n = 0
fib(n) == 1 if n = 1
#+END_EXAMPLE
** 求杨辉三角第n行第k列的值
 #+BEGIN_EXAMPLE
	1           # lst[0][0] = 1
  1   1         # lst[1][0] = 1 lst[1][-1] = 1
1   2   1       # lst[2][0] = 1 lst[2][1] = 2 = lst[1][0] + lst[1][1] lst[2][-1] = 1
1   3   3   1     # lst[3][0] = 1 lst[3][1] = lst[2][0] + lst[2][1] = 3 lst[3][2] = lst[2][1] + lst[2][2] lst[3][-1] = 1

n: n+1个元素
 #+END_EXAMPLE
n = 6

k = 4
*** 一般方法实现
#+BEGIN_SRC python :results output code :exports both
n = 6
k = 4
lst = []
for i in range(n+1):
	row = [1]
	lst.append(row)
	if i == 0:
		continue
	for j in range(1, i):
		row.append(lst[i-1][j-1]+lst[i-1][j])
	row.append(1)

print(lst[n][k])
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
15
#+END_SRC
*** 使用解析式实现
** 矩阵转置
#+BEGIN_SRC python :results output code :exports both
a = [
	[1, 2, 3],
	[4, 5, 6]
]

ret = []

for row in a:
	for j, col in enumerate(row):
		if len(ret) - 1 < j:
			ret.append([])
		ret[j].append(col)
print(ret)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
[[1, 4], [2, 5], [3, 6]]
#+END_SRC
** 判断一个方程是否可逆，如果可逆求其逆矩阵
** 按单词反转字符串，例如"I love python"，反转为"python love I"
 #+BEGIN_SRC python
s = 'I love python'
' '.join(s.split()[::-1])
 #+END_SRC
** 找出一个列表，只出现了一次的数字，并且保持原来的次序
例如[1, 2, 1, 3, 2, 5]，结果为[3, 5]。
 #+BEGIN_SRC python
lst = [1, 2, 1, 3, 2, 5]
tmp = []
ret = []
for x in lst:
  if x not in tmp:
	  ret.append(x)
	  tmp.append(x)
  else:
	  if x in ret:
		  ret.remove(x)
ret
 #+END_SRC
** 求两个列表的笛卡尔积
什么是笛卡尔积？
 #+BEGIN_SRC python
lst1 = list(range(0, 10))
lst2 = list(range(3, 8))

[(x, y) for x in lst1 for y in lst2]
 #+END_SRC
** 不使用组合数打印杨辉三角
** 判断一个四则运算的括号是否匹配
例如3*{3+[(2-3)*(4+5)]}的括号匹配的，而
** 使用3种方法实现菲波那切数列
 1. 递归
	#+BEGIN_SRC python
def fib1(n):
  if n == 0 or n == 1:
	  return 1
  return fib1(n-1) + fib1(n-2)

fib1(5)
	#+END_SRC
 2. 迭代的方式
	#+BEGIN_SRC python
def fib2(n):
  lst = []
  for i in range(n+1):
	  if i == 0 or i == 1:
		  lst.append(i)
	  else:
		  lst.append(lst[-1] + lst[-2])
  return lst.pop()
# 当n较大时，fib2效率低下

def fib22(n):
  a, b = 1, 1
  for i in range(n+1):
	  if i == 0 or i == 1:
		  a, b = 1, 1
	  else:
		  a, b = b, a+b
  return b
# 实现了滑动窗口
#        a  b
# [1, 1, 2, 3]
	#+END_SRC
 3. 生成器的实现
	#+BEGIN_SRC python
def fib_gen(n):
  idx = 0
  a, b = 1, 1
  while True:
	  if idx == 0 or idx == 1:
		  yield 1
	  else:
		  yield b
		  a, b = b, a+b
	  idx += 1

def fib3(n):
  gen = fib_gen()
  for _ in range(n+1):
	  next(gen)
  return next(gen)

	#+END_SRC
** 实现base64编码解码算法
base64主要用于把二进制转换为字符串。

base64的table： "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890+/"

1. 输入按3字节（24位）分组，不足3字节补0
2. 按6位分组，转化为整数
3. 整数作为table的索引
4. 补0的字节用=表示

首先把该问题分解为几个步骤：
1. 要被编码的字节进行以3个字节为单位进行分组
 #+BEGIN_SRC python :results output :exports both
   data = b'abcdefg'
   c = 0
   for x in range(3, len(data), 3):
	   print(data[c:x])
	   c += 3
 #+END_SRC

 #+RESULTS:
 : b'abc'
 : b'def'

2. 把分组得到的字节转化为整数
 #+BEGIN_SRC python :results output :exports both
   # int类型有一个from_bytes的方法，可以把二进制转换为整数
   print(int.from_bytes(b'abc', 'big'))
 #+END_SRC

 #+RESULTS:
 : 6382179

3. 得到每个分组的3个字节（共24位）以6位为单位进行分组
 #+BEGIN_SRC python :results output :exports both
   i = 6382179
   # 取第一个6位，右移18位即可
   print(i >> 18)

   # 取第二个6位，右移12位并与0b111111做与操作
   print(i >> 12 & 0b111111) # hex(0b111111)

   # 取第三个6位，右移6位并与0b111111做与操作
   print(i >> 6 & 0b111111)

   # 取第四个6位，直接与0b111111做与操作
   print(i & 0b111111)
 #+END_SRC

 #+RESULTS:
 : 24
 : 22
 : 9
 : 35

4. 以上个步骤得到的数字为索引，从table中取出相应的编码
 #+BEGIN_SRC python :results output :exports both
   table = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890+/'
   arr = bytearray()
   arr.extend([table[24], table[22], table[9], table[35]])
   print(arr)
 #+END_SRC

 #+RESULTS:
 : bytearray(b'YWJj')

*** base64编码
#+BEGIN_SRC python :results output :exports both
def b64encode(data: bytes) -> str:
	table = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890+/'
	encoded = bytearray()
	c = 0
	for x in range(3, len(data)+1, 3):
		print(data[c:x])
		i = int.from_bytes(data[c:x], 'big')
		for j in range(1, 5):
			encoded.append(table[i >> (24-j*6) & 0x3f])
		c += 3
	r = len(data) - c
	if r > 0:
		i = int.from_bytes(data[c:], 'big') << (3-r) * 8
		for j in range(1, 5-(3-r)):
			encoded.append(table[i >> (24-j*6) & 0x3f])
		for _ in range(3-r):
			encoded.append(int.from_bytes(b'=', 'big'))
	return encoded.decode()

print(b64encode(b'abcdefg'))
#+END_SRC

#+RESULTS:
: b'abc'
: b'def'
: YWJjZGVmZw==

*** base64解码
#+BEGIN_SRC python :results output :exports both
def b64decode(data: str) -> bytes:
	table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuwxyz0123456789+/'
	decoded = bytearray()
	s = 0
	for e in range(4, len(data)+1, 4):
		tmp = 0
		for i, c in enumerate(data[s:e]):
			if c != '=':
				tmp += table.index(c) << 24 - (i+1) * 6
			else:
				tmp += 0 << 24 - (i+1) * 6
		decoded.extend(tmp.to_bytes(3, 'big'))
		s += 4
	return bytes(decoded.rstrip(b'\x00'))

e = 'YWJj'
print(b64decode(e))
#+END_SRC

#+RESULTS:
: b'abc'

** 实现计数器，可以指定基数和步长
我的实现（有点不符合题意）：
#+BEGIN_SRC python :results output :exports both
def make_inc(base=0, step=1):
	 def counter():
		 x = base
		 while True:
			 x += step
			 yield x
	 c = counter()
	 return lambda: next(c)

incr = make_inc(0, 1)
for i in range(3):
	 print(incr())
print('--------------------')
incr = make_inc(1, 2)
for i in range(3):
	 print(incr())
#+END_SRC

#+RESULTS:
: 1
: 2
: 3
: --------------------
: 3
: 5
: 7

听课时的笔记：
#+BEGIN_SRC python :results output :exports both
def counter(i):
	base = i
	def inc(x=1):
		nonlocal base
		base += x
		return base
	return inc

inc = counter(3)
print(inc(3))
#+END_SRC

#+RESULTS:
: 6

** 写一个函数，实现对整数的排序，默认升序排列
不能使用第三方库函数。

用自己的话描述插入排序的过程：

 #+BEGIN_SRC python
def sort(lst, reverse=False):
  dst = []
  for n in lst:
	  for i, e in enumerate(dst):
		  if not reverse:
			  if n < e:
				  dst.insert(i, n)
				  break
		  else:
			  if n > e:
				  dst.insert(i, n)
	  else:
		  dst.append(n)
  return dst

sort([3, 2, 1, 5, 4, 7, 8, 6])
sort([3, 2, 1, 5, 4, 7, 8, 6], reverse=True)
 #+END_SRC
** cache装饰器
实现可过期，可清除，不换出。

实现LRU换出。
#+BEGIN_SRC python :results output :exports both
from functools import wraps
import inspect
import datetime


def cache(exp=0):
	def _cache(fn):
		cache = {}
		@wraps(fn)
		def wrap(*args, **kwargs):
			# TODO key 如何拼装
			key = []
			names = set()
			params = inspect.signature(fn).parameters
			# 以下4行是对位置参数的处理
			for i, arg in enumerate(args):
				name = list(params.keys())[i]
				key.append((name, arg))
				names.add(name)
			# 下面一行是对关键字参数的处理
			key.extend(kwargs.items())
			names.update(kwargs.keys())
			# 对默认参数的处理
			for k, v in params.items():
				if k not in names:
					key.append((k, v.default))
			# 对key进行排序
			key.sort(key=lambda x: x[0])
			key = '&'.join(['{}={}'.format(name, arg) for name, arg in key])
			print(key)
			if key in cache.keys():
				ret, timestamp = cache[key]
				if exp == 0 or datetime.datetime.now().timestamp() - timestamp < exp:
					print('cache hit')
					return ret
			ret = fn(*args, **kwargs)
			print('cache miss')
			cache[key] = (ret, datetime.datetime.now().timestamp())
			return ret
		return wrap
	return _cache


@cache(5)
def add(x, y=3):
	return x + y

add(1, 3)
#+END_SRC

#+RESULTS:
: x=1&y=3
: cache miss

** 实现带过期的LRU缓存装饰器
** 写一个命令分发器，用户输入指令，执行相应的函数
** 实现find命令
至少实现如下选项并测试：
+ -name
+ -type
+ -ctime
+ -mtime
+ -cnewer
+ -executable
+ -newer
+ -gid
+ -uid
** 实现cp命令
使用shutil库来实现。至少实现-r、-p选项。
** 自己实现partial函数
** 实现字典
字典的实现方法：开地址法、拉链法。

 #+BEGIN_SRC python :results output :exports both
   class Node:
	   def __init__(self, key, value):
		   self.key = key
		   self.value = value


   class Dict:
	   def __init__(self, cap=128):
		   self.cap = cap
		   self.slots = []
		   for x in range(cap):
			   self.slots.append([])

	   def __get_slot(self, key):
		   return self.slots[hash(key) % self.cap]

	   def put(self, key, value):
		   node = Node(key, value)
		   slot = self.__get_slot(key)
		   slot.append(node)

	   def get(self, key, defalut=None):
		   slot = self.__get_slot(key)
		   for node in slot:
			   if node.key == key:
				   return node.value
		   return defalut

	   def remove(self, key):
		   slot = self.__get_slot(key)
		   idx = -1
		   for i, node in enumerate(slot):
			   if node.key == key:
				   idx = i
		   if idx >= 0:
			   slot.pop(idx)

d = Dict()
d.put('a', 1)
d.get('a')
d.remove('a')
 #+END_SRC
** 写一个函数，判断两个字典是否相等
字典的value可能为数字，字符串，元组，列表，集合和字典。如果value为
列表和字典，需要判断其中每个元素是否相等。(在Python3中，可以直接判断字典相等)
 #+BEGIN_SRC python
def dict_eq(a, b):
  for k, v in a.items():
	  if k not in b.keys():
		  return False
	  else:
		  if not isinstance(v, (dict, list)):
			  if v != b[k]:
				  return False
		  if isinstance(v, list):
			  for i, item in enumerate(v):
				  if len(b[k]) <= i:
					  return False
				  if b[k][i] != item:
					  return False
		  if isinstance(v, dict):
			  ret = dict_eq(v, b[k])
			  if ret is False:
				  return ret
 #+END_SRC
** 模拟一个数据源不断的产生数值，求一段时间内，最大的K个元素
Top K的问题
 #+BEGIN_SRC python
import random
import time
import datetime


def data_source():
  while True:
	  yield random.randint(0, 100)
	  time.sleep(0.1)

ds = data_source()
for _ in range(10):
  print(next(ds))


def top_k1(k, time=3):
  start = datetime.datetime.now()
  lst = []
  while True:
	  lst.append(next(ds))
	  current = datetime.datetime.now()
	  if (current - start).total_seconds() >= time:
		  start = current
		  lst.sort()
		  ret = []
		  for _ in range(k):
			  ret.append(lst.pop())
		  yield ret

g = top_k1(10)
for _ in range(3):
  print(next(g))

# 方法2
def top_k2(k, time=3):
  start = datetime.datetime.now()
  lst = []
  while True:
	  e = next(ds)
	  for i, v in enumerate(lst):
		  if e < v:
			  lst.insert(i, e)
			  break
	  else:
		  lst.append(e)
	  current = datetime.datetime.now()
	  if (current - start).total_seconds() >= time:
		  start = current
		  ret = []
		  for _ in range(k):
			  ret.append(lst.pop())
		  yield ret

g2 = top_k2(10)
for _ in range(3):
  print(next(g))

# 二叉树
# data[i].left = data[2i+1]
# data[i].right = data[2i+2]
# data[i].parent = data[floor((i-1)/2)]
# 只看父子，不看兄弟
# 使用堆的方式来实现
def heap():
  data = []
  def add(e):
	  idx = len(data)
	  data.append(e)
	  parent_idx = (idx-1) // 2
	  while parent_idx >= 0:
		  if data[idx] > data[parent_idx]:
			  data[parent_idx], data[idx] = data[idx], data[parent_idx]
		  else:
			  break

  def pop(idx=0):
	  if not data:
		  return None
	  if len(data) == 1:
		  return data.pop()
	  ret = data[idx]
	  data[idx] = data.pop()
	  left_idx = 2 * idx + 1
	  right_idx = left_idx + 1
	  while left_idx < len(data):
		  child_idx = left_idx
		  if right_idx < len(data) and data[right_idx] > data[left_idx]:
			  child_idx = right_idx
		  if data[idx] < data[child_idx]:
			  data[idx], data[child_idx] = data[child_idx], data[idx]
			  idx = child_idx
			  left_idx = 2 * idx + 1
			  right_idx = left_idx + 1
		  else:
			  break
	  return ret
  return add, pop
# add和父节点比较大小，如果比父节点大，交换
# pop和两个子节点比较，如果比子节点小，和较大的子节点交换
add, pop = heap()
for _ in range(10):
  add(random.randint(0, 100))

for _ in range(10):
  print(pop())

# top_k3
def top_k3(k, time=3):
  start = datetime.datetime.now()
  add, pop = heap()
  while True:
	  add(next(ds))
	  current = datetime.datetime.now()
	  if (current - start).total_seconds() >= time:
		  start = current
		  ret = []
		  for _ in range(k):
			  ret.append(pop())
		  yield ret
g3 = top_k3(10)
for _ in range(3):
  print(next(g3))
 #+END_SRC
** 实现os.walk方法
 #+BEGIN_SRC python
import os


# 深度优先
def walk(root):
  # 深度优先需要一个栈
  stack = [root]
  files = []
  while stack:
	  cur = stack.pop()
	  for x in os.scandir(cur):
		  if x.is_dir():
			  stack.append(x.path)
		  else:
			  files.append(x.path)
  return files
walk('.')

# 广度优先
def walk_2(root):
  # 需要一个队列
  queue = []
  files = []
  while queue:
	  cur = queue.pop(0)
	  fox x in os.scandir(cur):
		  if x.is_dir():
			  queue.append(x.path)
		  else:
			  files.append(x.path)
  return files

# 递归
def walk3(root):
  stack = [root]
  files = []
  for x in os.scandir(root):
	  if x.is_dir():
		  walk3(x.path)
	  else:
		  yield x.path
 #+END_SRC
** 实现LinkedList
#+BEGIN_SRC python :results output :exports both
class Node:
	def __init__(self, value):
		self.value = value
		self.next = None


class LinkedList:
	def __init__(self):
		self.head = None

	def __find_tail(self):
		current = self.head
		while current.next is not None:
			current = current.next
		return current

	def append(self, value):
		node = Node(value)
		if self.head is None:
			self.head = node
		else:
			tail = self.__find_tail()
			tail.next = node

	def pop(self):
		if self.head is None:
			return None
		tail = self.__find_tail()
#+END_SRC
** 实现优先队列
2017-02-25日上课，以类的方式实现：
#+BEGIN_SRC python :results output :exports both
class Heap:
	@staticmethod
	def cmp(x, y):
		if x > y:
			return 1
		if x < y:
			return -1
		return 0

	def __init__(self, cmp=None):
		if cmp is None:
			self.cmp = Heap.cmp
		self.data = []

	def put(self, value):
		i = len(self.data)
		self.data.append(value)
		pi = (i-1) // 2
		while pi > 0 and cmp(value, data[pi]) > 0:
			self.data[pi], self.data[i] = self.data[i], self.data[pi]
			i = pi
			pi = (i-1) // 2
#+END_SRC
** 实现优先队列
1. 完全有序，入队的时候做一次排序
 #+BEGIN_SRC python :results output :exports both
   queue = []


   def queue():
	   lst = []

	   def put(value, priority):
		   for i, item in enumerate(lst):
			   if item[1] <= priority:
				   lst.insert(i, (value, priority))
				   break
		   else:
			   lst.append((value, priority))

	   def pop():
		   if lst:
			   return lst.pop()[0]
		   return None

	   return put, pop

   put, pop = queue()
   put(1, 1)
   put(3, 2)
   put(5, 5)

   print(pop())
   print(pop())
 #+END_SRC

 #+RESULTS:
 : 1
 : 3

2. heap实现
 + heap是完全二叉树
 + 父节点总是比子节点大（小）
 + 完全二叉树可以使用列表表示
   + data[0]是根节点
   + data[i].left = data[2i+1]
   + data[i].right = data[2i+2]
   + data[i].parent = data[floor((i-1)/2)]

** 实现一个优先队列，由用户指定比较函数
#+BEGIN_SRC python :results output :exports both
# 命名元组
from collections import namedtuple

t = (1, 2, 3)
t[0]
1
User = namedtuple('User', ['name', 'mail', 'age'])
user = User('lavenliu', 'lcc@lavenliu.cn', 18)
print(user)
type(user)
print(user.name)
print(user.age)
#+END_SRC

#+RESULTS:
: User(name='lavenliu', mail='lcc@lavenliu.cn', age=18)
: lavenliu
: 18

** 实现tail -f的功能
 #+BEGIN_SRC python
import time
import threading


def tailf(path):
  offset = 0
  while True:
	  with open(path) as f:
		  if offset > f.tell():
			  offset = 0
		  f.seek(offset)
		  for line in f:
			  yield line # 在Python3中，可以用yield from f替换此行及上面一行
		  offset = f.tell()
	  time.sleep(1)


def tailf_1(path):
  offset = 0
  event = threading.Event()
  try:
	  while not event.is_set():
		  with open(path) as f:
			  f.seek(offset)
			  yield from f
			  offset = f.tell()
		  event.wait(1)
  except KeyboardInterrupt:
	  event.set()

for x in tailf('/root/utf8.txt'):
  print(x,)
 #+END_SRC
** 实现tail命令，包括-n和-f选项，可以使用argparse实现命令行参数解析
如何读取最后的若干行呢？可以从前往后读，设置一个大小为n的暂存区，直
到读到文件末尾，然后返回这个暂存区。
 #+BEGIN_SRC python
import os
import argparse
from collections import deque


class Tail:
  def __init__(self, file):
	  self.file = file
	  self.offset = 0

  def follow(self):
	  while True:
		  with open(self.file) as f:
			  # TODO
			  f.seek(self.offset)
			  yield from f
			  self.offset = f.tell()

  # def last(self, n):
  #     tmp_buff = deque(maxlen=n)
  #     with open(self.file) as f:
  #         for line in f:
  #             tmp_buff.append(line)
  #     yield from tmp_buff
  # 上述的方法效率低

  def last(self, n):
	  buf_length = 1024
	  lines = []
	  size = os.stat(self.file).st_size
	  with open(self.file) as f:
		  x = 1
		  while True:
			  if x * buf_length > size:
				  break
			  f.seek(size - x * buf_length)
			  buf = f.read(buf_length)
			  tmp_lines = buf.splitlines()
			  if not tmp_lines[-1].endwith('\n') and lines:
				  line = tmp_lines.pop() + lines.pop(0)
				  tmp_lines.append(line)
				  tmp_lines.extend(lines)
				  lines = tmp_lines
				  if len(lines) >= n:
					  break
			  x += 1
	  if len(lines) >= n:
		  yield from lines[-n:]
	  else:
		  yield from lines
 #+END_SRC

deque的使用：
 #+BEGIN_SRC python
from collections import deque

# q里只保存5个值
q = deque(maxlen=5)
q.append(1)
q
for x in range(10):
  q.append(x)
q
# q里只保存5个值
 #+END_SRC

argparse的用法：
#+BEGIN_SRC python

#+END_SRC
** 不用内置数据结构，实现栈、队列和列表
 #+BEGIN_SRC python
class Node:
  def __init__(self, value):
	  self.value = value
	  self.next = None


class Stack:
  def __init__(self):
	  self.top = None

  def push(self, val):
	  node = Node(val)
	  node.next = self.top
	  self.top = node

  def pop(self):
	  if self.top is not None:
		  top = self.top
		  self.top = self.top.next
		  return top.value
	  return None

stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
stack.pop()
stack.pop()
stack.pop()
 #+END_SRC   
** 实现staticmethod装饰器
** 实现contextlib.contextmanager装饰器
第九周作业：
#+BEGIN_SRC python :results output :exports both
from functools import wraps


class ContextManager:
	def __init__(self, fn, *args, **kwargs):
		self.gen = fn(*args, **kwargs)

	def __enter__(self):
		return next(self.gen)

	def __exit__(self, *args):
		try:
			return next(self.gen)
		except StopIteration as e:
			return False


def contextmanager(fn):
	@wraps(fn)
	def wrap(*args, **kwargs):
		return ContextManager(fn, *args, **kwargs)
	return wrap


@contextmanager
def context():
	'''example context'''
	print('setup')
	try:
		yield 'value'
	finally:
		print('cleanup')

help(context)
#+END_SRC

#+RESULTS:
: Help on function context in module __main__:
: 
: context()
:     example context
: 

** 实现super函数
第九周作业：
** 假设已经存在函数get_permissions可以获取当前用户的权限列表
设计一个权限管理类，既可以作为装饰器，对一个函数授权，也可以作为上
下文管理，对一段代码授权。例如：
 #+BEGIN_SRC python
permissions = get_permissions()

if 'admin' in permissions:
  ## do somethings
else:
  raise Exception('Permission Denied')
 #+END_SRC
* Misc
** Dash
Dash许可证：https://kapeli.com/licenses/Dash/2017/043/4Zc6nmyvMCHNdp9xCozMj9C7mbdBaZ/license.dash-license
** influxdb
 #+BEGIN_SRC sh
cat <<EOF | sudo tee /etc/yum.repos.d/influxdb.repo 
[influxdb] 
name = InfluxDB Repository - RHEL \$releasever 
baseurl = https://repos.influxdata.com/rhel/\$releasever/\$basearch/stable 
enabled = 1 
gpgcheck = 1 
gpgkey = https://repos.influxdata.com/influxdb.key 
EOF
 #+END_SRC

安装：
 #+BEGIN_SRC sh
yum install influxdb
systemctl start influxdb.service
systemctl enable influxdb.service

[root@VM_113_230_centos ~]# netstat -antup |grep influxdb
tcp6       0      0 :::8083                 :::*                    LISTEN      18135/influxdb      
tcp6       0      0 :::8086                 :::*                    LISTEN      18135/influxdb      
tcp6       0      0 :::8090                 :::*                    LISTEN      18135/influxdb      
tcp6       0      0 :::8099                 :::*                    LISTEN      18135/influxdb

firewall-cmd --permanent --zone=public --add-port=8086/tcp
firewall-cmd --permanent --zone=public --add-port=8083/tcp
firewall-cmd --reload

http://<serverip>:8083/
 #+END_SRC
** 运维的危机
运维的方向：
1. 资深专家
2. 开发
** 编程心得
对于抽象的问题可以具体化；在理解之后，再进行抽象化。

先具体后抽象。

县具体后抽象。

可以一步一步的拆解，再合并。

找规律

纸和笔。
** \n与\r的区别
1. \n是让纸带上移一行
2. \r是让针头回到开始位置
** python org-mode
#+NAME: Example_Code
#+HEADER: :var print_this="Org mode code-block example output"
#+BEGIN_SRC python :results output code :exports results
print(print_this)
print(list(range(10)))
#+END_SRC

#+RESULTS: Example_Code
#+BEGIN_SRC python
Org mode code-block example output
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
#+END_SRC

一个函数的例子：
#+NAME: func_code
#+HEADER: :var mylist="[1, 2, 3, 4, 5, 6]"
#+BEGIN_SRC python :results output code :exports results
def print_list(*mylist):
	for i in mylist:
		print(i)

print_list(mylist)
#+END_SRC

#+RESULTS: func_code
#+BEGIN_SRC python
[1, 2, 3, 4, 5, 6]
#+END_SRC

** python postgresql
#+BEGIN_SRC python
import psycopg2 as p
con = p.connect("dbname='demo' user='postgres' host='localhost'")
cur = con.cursor()
cur.execute("select * from contracts")
rows = cur.fetchall()
print(rows)
for row in rows:
	print row

import psycopg2.extras as e
cur = con.cursor(cursor_factory=e.DictCursor)
cur.execute("select * from contracts")
rows = cur.fetchall()
for row in rows:
	print row["firstname"]
#+END_SRC

把文本文件写入到postgres中，
#+BEGIN_SRC python
import psycopg2 as p

fd = open('data_export', 'w')
# fd = open('data_export', 'r')
# cur.copy_from(fd, 'contacts', sep='|')
# cur.commit()
con = p.connect("dbname='demo' user='postgres' host='localhost'")
cur = con.cursor()
cur.copy_to(fd, 'contacts', sep='|')
#+END_SRC

data_export文件内容：
#+BEGIN_SRC sh
cat data_export
john|smith|1111111|london
tom|jones|2222222|pairs
joe|blogs|3333333|london
sam|edwards|4444444|shanghai
#+END_SRC

postgres,
#+BEGIN_SRC sql
select * from pg_language;
#+END_SRC
** c
#+name: cocktail.c
#+begin_src C :noweb yes :tangle cocktail.c
#include <stdio.h>
<<cocktail-sort>>
<<main>>
#+end_src

#+name: main
#+begin_src C
int main(int argc, char *argv[]) {
  int lst[argc-1];
  int i;
  for(i=1;i<argc;i++)
	lst[i-1] = atoi(argv[i]);
  sort(lst, argc-1);
  for(i=1;i<argc;i++)
	printf("%d ", lst[i-1]);
  printf("\n");
} 
#+end_src


#+name: cocktail-sort
#+begin_src C :noweb yes
void sort(int *a, unsigned int l)
{
int swapped = 0;
int i;
do {
  for(i=0; i < (l-1); i++) {
	<<swap>> 
  }
  if ( swapped == 0 ) break;
  swapped = 0;
  for(i= l - 2; i >= 0; i--) {
	<<swap>> 
  }
} while(swapped > 0);
}
#+end_src

#+name: swap
#+begin_src C
if ( a[i] > a[i+1] ) {
 int temp = a[i];
 a[i] = a[i+1];
 a[i+1] = temp;
 swapped = 1;
} 
#+end_src

#+call: cocktail.c[:cmdline 8 7 6 3 2 4 78]()

#+RESULTS:
: 2 3 4 6 7 8 78

** 杨辉三角
#+name: pascals-triangle
#+begin_src python :var n=5 :exports results :return pascals_triangle(5)
 def pascals_triangle(n):
	 if n == 0:
		 return [[1]]
	 prev_triangle = pascals_triangle(n-1)
	 prev_row = prev_triangle[n-1]
	 this_row = map(sum, zip([0] + prev_row, prev_row + [0]))
	 return prev_triangle + [this_row]

 #return pascals_triangle(n)
#+end_src

#+RESULTS: pascals-triangle

** org-mode python session
#+BEGIN_SRC python :session
def foo(x):
	if x > 0:
		return x+1
	else:
		return x-1

foo(1)
#+END_SRC

#+RESULTS:
: 2
** org-mode python non-session
使用return()，
#+BEGIN_SRC python
def foo(x):
	if x > 0:
		return x+1
	else:
		return x-1

return foo(5)
#+END_SRC

#+RESULTS:
: 6

#+begin_src python :session :results file
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
fig=plt.figure(figsize=(3,2))
plt.plot([1,3,2])
fig.tight_layout()
plt.savefig('images/myfig.pdf')
'images/myfig.pdf' # return this to org-mode
#+end_src

#+RESULTS:
[[file:images/myfig.pdf]]

** 比较好的网站
http://leetcode.com
** Base64编码表
#+TBLNAME: base64
|------+------+----+------+------+----+------+------+----+------+------|
| 码值 | 字符 | 空 | 码值 | 字符 | 空 | 码值 | 字符 | 空 | 码值 | 字符 |
|------+------+----+------+------+----+------+------+----+------+------|
|    0 | A    |    |   16 | Q    |    |   32 | g    |    |   48 |    w |
|------+------+----+------+------+----+------+------+----+------+------|
|    1 | B    |    |   17 | R    |    |   33 | h    |    |   49 |    x |
|------+------+----+------+------+----+------+------+----+------+------|
|    2 | C    |    |   18 | S    |    |   34 | i    |    |   50 |    y |
|------+------+----+------+------+----+------+------+----+------+------|
|    3 | D    |    |   19 | T    |    |   35 | j    |    |   51 |    z |
|------+------+----+------+------+----+------+------+----+------+------|
|    4 | E    |    |   20 | U    |    |   36 | k    |    |   52 |    0 |
|------+------+----+------+------+----+------+------+----+------+------|
|    5 | F    |    |   21 | V    |    |   37 | i    |    |   53 |    1 |
|------+------+----+------+------+----+------+------+----+------+------|
|    6 | G    |    |   22 | W    |    |   38 | m    |    |   54 |    2 |
|------+------+----+------+------+----+------+------+----+------+------|
|    7 | H    |    |   23 | X    |    |   39 | n    |    |   55 |    3 |
|------+------+----+------+------+----+------+------+----+------+------|
|    8 | I    |    |   24 | Y    |    |   40 | o    |    |   56 |    4 |
|------+------+----+------+------+----+------+------+----+------+------|
|    9 | J    |    |   25 | Z    |    |   41 | p    |    |   57 |    5 |
|------+------+----+------+------+----+------+------+----+------+------|
|   10 | K    |    |   26 | a    |    |   42 | q    |    |   58 |    6 |
|------+------+----+------+------+----+------+------+----+------+------|
|   11 | L    |    |   27 | b    |    |   43 | r    |    |   59 |    7 |
|------+------+----+------+------+----+------+------+----+------+------|
|   12 | M    |    |   28 | c    |    |   44 | s    |    |   60 |    8 |
|------+------+----+------+------+----+------+------+----+------+------|
|   13 | N    |    |   29 | d    |    |   45 | t    |    |   61 |    9 |
|------+------+----+------+------+----+------+------+----+------+------|
|   14 | O    |    |   30 | e    |    |   46 | u    |    |   62 |    + |
|------+------+----+------+------+----+------+------+----+------+------|
|   15 | P    |    |   31 | f    |    |   47 | v    |    |   63 |    / |
|------+------+----+------+------+----+------+------+----+------+------|
** 如何排查问题
1. 自底向上
2. 从最接近入口的地方去print
3. 逐渐深入进去
** 需要看的书
1. 计算机组成原理
2. 操作系统原理
3. 编译原理
4. 数据库系统原理
** Python元编程
 #+BEGIN_SRC sh
https://www.youtube.com/watch?v=sPiWg5jSoZI
 #+END_SRC
* Python课程开始复习
** 20170528
复习的内容：
1. 字典扁平化（递归方式实现、循环方式实现）
2. 最长公共字串（动态规划思想）

高阶函数：
1. 返回一个函数

装饰器：
1. 装饰器的副作用
2. 如何解决装饰器副作用

#+BEGIN_SRC python :results output :exports both
import time
import datetime


def logger(fn):
	def wrap(*args, **kwargs):
		start = datetime.datetime.now()
		ret = fn(*args, **kwargs)
		end = datetime.datetime.now()
		print('call {} took {}'.format(fn.__name__, end-start))
		return ret
	return wrap


@logger
def sleep(x):
	time.sleep(x)

print(sleep.__name__)
#+END_SRC

#+RESULTS:
: wrap

从这个例子中，我们可以看出sleep函数被logger函数装饰后，其属性__name__已经发生了变化。

有的Web框架依赖函数的名字，如视图函数。接下来改进上面的函数，使其的__name__属性可以编的正常。
#+BEGIN_SRC python :results output :exports both
import datetime

def logger(fn):
	  def wrap(*args, **kwargs):
		  start = datetime.datetime.now()
		  ret = fn(*args, **kwargs)
		  end = datetime.datetime.now()
		  print('call {} took {}'.format(fn.__name__, end-start))
		  return ret
	  wrap.__name__ = fn.__name__
	  wrap.__doc__ = fn.__doc__
	  return wrap
#+END_SRC

我们还可以把logger函数中的如下两行给提取出来，做一个单独的函数：
#+BEGIN_SRC python :results output :exports both
def copy_properties(src, dst):
	dst.__name__ = src.__name__
	dst.__doc__ = src.__doc__
#+END_SRC

logger函数改造为：
#+BEGIN_SRC python :results output :exports both
import datetime

def logger(fn):
	def wrap(*args, **kwargs):
		start = datetime.datetime.now()
		ret = fn(*args, **kwargs)
		end = datetime.datetime.now()
		print('call {} took {}'.format(fn.__name__, end-start))
		return ret
	copy_properties(fn, wrap)
	return wrap
#+END_SRC

对上面的copy_properties函数再进行改进（柯里化），
#+BEGIN_SRC python :results output :exports both
def copy_properties(src, dst):
	def _copy(dst):
		dst.__name__ = src.__name__
		dst.__doc__ = src.__doc__
	return _copy
#+END_SRC

那么logger函数也相应的变为：
#+BEGIN_SRC python :results output :exports both
import datetime

def logger(fn):
	def wrap(*args, **kwargs):
		start = datetime.datetime.now()
		ret = fn(*args, **kwargs)
		end = datetime.datetime.now()
		print('call {} took {}'.format(fn.__name__, end-start))
		return ret
	copy_properties(fn)(wrap)
	return wrap
#+END_SRC

继续改造copy_properties函数，使其称为一个装饰器：
#+BEGIN_SRC python :results output :exports both
def copy_properties(src):
	def _copy(dst):
		dst.__name__ = src.__name__
		dst.__doc__ = src.__doc__
		return dst
	return _copy
#+END_SRC

logger函数变为：
#+BEGIN_SRC python :results output :exports both
import datetime


def logger(fn):
	@copy_properties(fn)
	def wrap(*args, **kwargs):
		start = datetime.datetime.now()
		ret = fn(*args, **kwargs)
		end = datetime.datetime.now()
		print('call {} took {}'.format(fn.__name__, end-start))
		return ret
	return wrap
#+END_SRC

通过上面的折腾，其实我们想要表达的是想使用functools.wraps方法来实现上述的需求。

#+BEGIN_SRC python :results output :exports both
  import datetime
  import functools


  def logger(fn):
	  @functools.wraps(fn)
	  def wrap(*args, **kwargs):
		  start = datetime.datetime.now()
		  ret = fn(*args, **kwargs)
		  end = datetime.datetime.now()
		  print('call {} took {}'.format(fn.__name__, end-start))
		  return ret
	  return wrap


@logger
def sleep(x):
	time.sleep(x)

print(sleep.__name__)
#+END_SRC

带参数的装饰器。
